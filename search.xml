<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Excel VBA 生成目录列表</title>
    <url>/Excel%20VBA%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一键生成带锚点的目录列表"><a href="#一键生成带锚点的目录列表" class="headerlink" title="一键生成带锚点的目录列表"></a>一键生成带锚点的目录列表</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">Excel生成目录VBA</span><br><span class="line">Sub dic()</span><br><span class="line">    On Error GoTo back_out</span><br><span class="line">    Dim i As Integer</span><br><span class="line">    Dim ShtCount As Integer</span><br><span class="line">    Dim SelectionCell As Range</span><br><span class="line"></span><br><span class="line">    ShtCount = Worksheets.Count</span><br><span class="line">    If ShtCount = 0 Or ShtCount = 1 Then Exit Sub</span><br><span class="line">    Application.ScreenUpdating = False</span><br><span class="line">    For i = 1 To ShtCount</span><br><span class="line">        If Sheets(i).Name = "目录" Then</span><br><span class="line">            Sheets("目录").Move Before:=Sheets(1)</span><br><span class="line">        End If</span><br><span class="line">    Next i</span><br><span class="line">    If Sheets(1).Name &lt;&gt; "目录" Then</span><br><span class="line">        ShtCount = ShtCount + 1</span><br><span class="line">        Sheets(1).Select</span><br><span class="line">        Sheets.Add</span><br><span class="line">        Sheets(1).Name = "目录"</span><br><span class="line">    End If</span><br><span class="line">    Sheets("目录").Select</span><br><span class="line">    Columns("B:B").Delete Shift:=xlToLeft</span><br><span class="line">    Application.StatusBar = "正在生成目录…………请等待！"</span><br><span class="line">    For i = 2 To ShtCount</span><br><span class="line">        ActiveSheet.Hyperlinks.Add Anchor:=Worksheets("目录").Cells(i, 2), Address:="", SubAddress:= _</span><br><span class="line">            "'" &amp; Sheets(i).Name &amp; "'!R1C1", TextToDisplay:=Sheets(i).Name</span><br><span class="line">    Next</span><br><span class="line">    Sheets("目录").Select</span><br><span class="line">    Columns("B:B").AutoFit</span><br><span class="line">    Cells(1, 2) = "目录"</span><br><span class="line">    Set SelectionCell = Worksheets("目录").Range("B1")</span><br><span class="line">    With SelectionCell</span><br><span class="line">        .HorizontalAlignment = xlDistributed</span><br><span class="line">        .VerticalAlignment = xlCenter</span><br><span class="line">        .AddIndent = True</span><br><span class="line">        .Font.Bold = True</span><br><span class="line">        .Interior.ColorIndex = 34</span><br><span class="line">    End With</span><br><span class="line">    Application.StatusBar = False</span><br><span class="line">    Application.ScreenUpdating = True</span><br><span class="line">back_out:</span><br><span class="line">End Sub</span><br></pre></td></tr></tbody></table></figure>
<h3 id="一键生成sql"><a href="#一键生成sql" class="headerlink" title="一键生成sql"></a>一键生成sql</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">Sub AUTO_Click()</span><br><span class="line"></span><br><span class="line">'定义语句</span><br><span class="line">Dim sql As String</span><br><span class="line">Dim rowMax As Integer</span><br><span class="line">Dim start_line As Integer</span><br><span class="line">Dim end_line As Integer</span><br><span class="line">Dim flag As Boolean</span><br><span class="line"></span><br><span class="line">'变量初始化</span><br><span class="line">flag = False</span><br><span class="line"></span><br><span class="line">'获取行号</span><br><span class="line">start_line = Range("K3").Value</span><br><span class="line">end_line = Range("K4").Value</span><br><span class="line"></span><br><span class="line">'清空SQL语句</span><br><span class="line">Range("J5").Value = ""</span><br><span class="line"></span><br><span class="line">'获取最大行列数</span><br><span class="line">rowMax = Worksheets("Sheet1").Range("A65536").End(xlUp).Row</span><br><span class="line"></span><br><span class="line">'结束范围修正</span><br><span class="line">If (end_line - start_line) &lt; 1 And Len(Trim(start_line)) &gt; 0 Then</span><br><span class="line"></span><br><span class="line">end_line = start_line</span><br><span class="line">flag = True</span><br><span class="line">End If</span><br><span class="line">'验证行号</span><br><span class="line">If start_line = 0 Then</span><br><span class="line">MsgBox ("未指定起始行号，" &amp; rowMax &amp; "条记录将全部选中")</span><br><span class="line">start_line = 2</span><br><span class="line">end_line = rowMax</span><br><span class="line">flag = False</span><br><span class="line">sql = Replace(concatStr(start_line, end_line, flag), "INTO", "OVERWRITE TABLE ")</span><br><span class="line">Else</span><br><span class="line">sql = concatStr(start_line, end_line, flag)</span><br><span class="line">End If</span><br><span class="line">sql = sql &amp; ";"</span><br><span class="line">Range("J5").Value = sql</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">'定义拼接函数</span><br><span class="line">Function concatStr(targetRow As Integer, endRow As Integer, process_flag As Boolean)</span><br><span class="line">Dim sql As String</span><br><span class="line">Dim rowVal As String</span><br><span class="line">sql = "INSERT INTO tmp.test_tab" &amp; Chr(10)</span><br><span class="line"></span><br><span class="line">For n = targetRow To endRow</span><br><span class="line">rowVal = n</span><br><span class="line">If process_flag Then</span><br><span class="line">rowVal = endRow</span><br><span class="line">End If</span><br><span class="line">sql = sql &amp; "SELECT """ &amp; Cells(rowVal, 1) &amp; """," &amp; """" &amp; Cells(rowVal, 2) &amp; """," &amp; """" &amp; Cells(rowVal, 3) &amp; """," &amp; """" &amp; Cells(rowVal, 4) &amp; """," &amp; """" &amp; Cells(rowVal, 5) &amp; """," &amp; """" &amp; Cells(rowVal, 6) &amp; """," &amp; """" &amp; Cells(rowVal, 7) &amp; """," &amp; """" &amp; Cells(rowVal, 8) &amp; """," &amp; """" &amp; Cells(rowVal, 9) &amp; """"</span><br><span class="line">If process_flag Then</span><br><span class="line">Exit For</span><br><span class="line">ElseIf ((endRow - n) &gt; 0) Then</span><br><span class="line">sql = sql &amp; Chr(10) &amp; "union all" &amp; Chr(10)</span><br><span class="line">End If</span><br><span class="line">Next n</span><br><span class="line"></span><br><span class="line">concatStr = sql</span><br><span class="line"></span><br><span class="line">End Function</span><br></pre></td></tr></tbody></table></figure>
<p>&nbsp;<br>&nbsp;</p>
<p><img src="/uploads/Excel/vba_exmple.jpg" alt="VBA生成Sql效果图" title="VBA生成Sql效果图"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Excel</tag>
        <tag>VBA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive、Spark常用技巧</title>
    <url>/Hive%E3%80%81Spark%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
    <content><![CDATA[<p><strong>建议使用关键字搜索查找所需配置</strong></p>
<h2 id="Hive-常用指令配置"><a href="#Hive-常用指令配置" class="headerlink" title="Hive 常用指令配置"></a>Hive 常用指令配置</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">mapred.child.java.opts=-Xmx1024m</span><br></pre></td></tr></tbody></table></figure>
<p>手工load时出现 <strong>java heap outofmemory</strong> 调整该设置以申请更大的内存资源</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.compute.query.using.stats</span><br></pre></td></tr></tbody></table></figure>
<p>当hive.compute.query.using.stats=true时，<code>select count(*) from</code> 将直接从元数据保存的统计信息中获取表中记录条数；<br>当hive.compute.query.using.stats=false时，<code>select count(*) from</code> 将会以集群模式运行返回结果<br><strong>注</strong>: hadoop fs -put 该方式无法通过元数据中获取记录数，如有需要需要设置该配置为false</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.exec.dynamic.partition</span><br></pre></td></tr></tbody></table></figure>
<p>缺省false；设置为true允许使用dynamic partition，即动态分区</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.exec.dynamic.partition.mode</span><br></pre></td></tr></tbody></table></figure>
<p>缺省strick；设置dynamic partition模式（nostrict允许所有partition列都为dynamic partition，strict不允许）</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.exec.max.dynamic.partitions.pernode</span><br></pre></td></tr></tbody></table></figure>
<p>缺省100；每一个mapreduce job允许创建的分区的最大数量，如果超过了这个数量就会报错</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.exec.max.dynamic.partitions</span><br></pre></td></tr></tbody></table></figure>
<p>缺省1000；一个dml语句允许创建的所有分区的最大数量</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.exec.max.created.files</span><br></pre></td></tr></tbody></table></figure>
<p>缺省100000；所有的mapreduce job允许创建的文件的最大数量</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.enforce.bucketing</span><br></pre></td></tr></tbody></table></figure>
<p>默认为false;启用则强制 bucketing,控制表是否进行分桶的设置</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.cli.print.header</span><br></pre></td></tr></tbody></table></figure>
<p>默认为false;控制查询结果是否显示列名</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">mapreduce.job.queuename</span><br></pre></td></tr></tbody></table></figure>
<p>指定资源队列</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.msck.path.validation=ignore</span><br></pre></td></tr></tbody></table></figure>
<p>修复分区配置，配合<code>msck repair table dbname.tbname</code>使用</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> lcoks [tab_name]</span><br></pre></td></tr></tbody></table></figure>
<p>查看表锁，也可以不加表名使用</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">unlock</span> <span class="keyword">table</span> tab_name [<span class="keyword">partition</span> (xx=xxxx)]</span><br></pre></td></tr></tbody></table></figure>
<p>释放表锁，<strong>表锁</strong> 和 <strong>分区锁</strong> 级别不同，独占锁在某个分区时需要指定目标分区释放</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">hive.support.concurrency=false</span><br></pre></td></tr></tbody></table></figure>
<p>遇到无法释放的死锁时，可以尝试暂时关闭并发锁设置（慎用）</p>
<ul>
<li><p>hive内部表与外部表互相转换</p>
<ul>
<li><p>转换外部表</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">SET</span> TBLPROPERTIES (<span class="string">'EXTERNAL'</span> = <span class="string">'true'</span>);</span><br><span class="line"><span class="comment">-- 修改完成后,查看MySQL元数据TBLS表,发现该表这条数据对应的TBL_TYPE字段变成了 EXTERNAL_TABLE</span></span><br><span class="line"><span class="comment">-- 尝试DROP这个table之后,该表在hdfs上面的数据不会被删除;但是元数据表TBLS里面关于该表的信息还是会被删除</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>转换内部表</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">SET</span> TBLPROPERTIES (<span class="string">'EXTERNAL'</span> = <span class="string">'false'</span>);</span><br><span class="line"><span class="comment">-- 修改完成后,查看MySQL元数据TBLS表,发现该表这条数据对应的TBL_TYPE字段变成了 MANAGED_TABLE</span></span><br><span class="line"><span class="comment">-- DROP这个table之后，hdfs上的数据和元数据表的信息都将被删除</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>注意</strong> ：在HIVE 4.0.0之后有过修改，如果需要设置外部表再删除时同时删除本地系统的数据，可以设置<code>external.table.purge=true</code>，<a href="https://issues.apache.org/jira/browse/HIVE-19981" target="_blank" rel="noopener">参考地址</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="Spark-常用指令配置"><a href="#Spark-常用指令配置" class="headerlink" title="Spark 常用指令配置"></a>Spark 常用指令配置</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">refresh table tab_name</span><br></pre></td></tr></tbody></table></figure>
<p>spark缓存刷新</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">spark.driver.maxResultSize=1g</span><br></pre></td></tr></tbody></table></figure>
<p>设置序列化结果的总大小限制（以字节为单位），可用后缀单位 (“k”, “m”, “g” or “t”) (e.g. 512m, 2g)</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">spark.app.name</span><br></pre></td></tr></tbody></table></figure>
<p>设置提交的spark task名称</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">spark.executor.memory</span><br></pre></td></tr></tbody></table></figure>
<p>每个执行程序进程使用的内存量，与具有大小单位的 JVM 内存字符串格式相同；可用后缀单位 (“k”, “m”, “g” or “t”) (e.g. 512m, 2g)</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">spark.driver.cores</span><br></pre></td></tr></tbody></table></figure>
<p>集群模式下可申请的计算内核数</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">spark.driver.memory</span><br></pre></td></tr></tbody></table></figure>
<p>client模式下无效；初始化SparkContext进程的驱动内存大小，可用后缀单位 (“k”, “m”, “g” or “t”) (e.g. 512m, 2g)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>数仓</tag>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化：Left join 技巧</title>
    <url>/SQL%E4%BC%98%E5%8C%96%EF%BC%9ALeft%20join%20%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>日常工作中，对于数据的分析/统计/筛选等过程中多有遇到需要排除大量数据范围的处理，那么大多数情况下<code>left join</code>来限制数据结果应该算是比较便捷；关于<code>left join</code>这里主要总结下在限制结果集时的技巧。<br>文章中所有查询结果均以下面A、B两张表样例数据为参考。</p>
<p><strong>表A</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">第一系列</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">第二系列</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">第三系列</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">第四系列</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">第五系列</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">其他系列</td>
</tr>
</tbody>
</table>
<p><strong>表B</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">100</td>
</tr>
</tbody>
</table>
<p><strong>建表语句：</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp.tab_a (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> <span class="string">`PRIMARY`</span> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp.tab_b (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    score <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> <span class="string">`PRIMARY`</span> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tmp.tab_a(<span class="keyword">id</span>,<span class="string">`name`</span>) </span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">'1'</span>,<span class="string">'第一系列'</span>),</span><br><span class="line">    (<span class="string">'2'</span>,<span class="string">'第二系列'</span>),</span><br><span class="line">    (<span class="string">'3'</span>,<span class="string">'第三系列'</span>),</span><br><span class="line">    (<span class="string">'4'</span>,<span class="string">'第四系列'</span>),</span><br><span class="line">    (<span class="string">'5'</span>,<span class="string">'第五系列'</span>),</span><br><span class="line">    (<span class="string">'6'</span>,<span class="string">'其他系列'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tmp.tab_a(<span class="keyword">id</span>,<span class="string">`name`</span>) </span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">'1'</span>,<span class="string">'90'</span>),</span><br><span class="line">    (<span class="string">'2'</span>,<span class="string">'20'</span>),</span><br><span class="line">    (<span class="string">'3'</span>,<span class="string">'30'</span>),</span><br><span class="line">    (<span class="string">'4'</span>,<span class="string">'60'</span>),</span><br><span class="line">    (<span class="string">'5'</span>,<span class="string">'100'</span>);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="样例一"><a href="#样例一" class="headerlink" title="样例一"></a>样例一</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.score</span><br><span class="line"><span class="keyword">from</span> tab_a a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab_b b</span><br><span class="line"><span class="keyword">on</span> a.id=b.id</span><br><span class="line"><span class="keyword">and</span> b.score=<span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>
<p>查询结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">第一系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">第二系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">第三系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">第四系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">第五系列</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">其他系列</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>在查询结果中，a表中的数据全部系列都会显示，b表的数据会按照score=100的条件来关联a表数据，最终在查询结果中找到的只有成绩为100的这条记录。</p>
<h2 id="样例二"><a href="#样例二" class="headerlink" title="样例二"></a>样例二</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.score</span><br><span class="line"><span class="keyword">from</span> tab_a a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab_b b</span><br><span class="line"><span class="keyword">on</span> a.id=b.id</span><br><span class="line"><span class="keyword">where</span> b.score=<span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>
<p>查询结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">第五系列</td>
<td style="text-align:center">100</td>
</tr>
</tbody>
</table>
<p>在查询结果中，数据会按照score=100的条件来过滤查询结果。</p>
<h2 id="样例三"><a href="#样例三" class="headerlink" title="样例三"></a>样例三</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.score</span><br><span class="line"><span class="keyword">from</span> tab_a a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab_b b</span><br><span class="line"><span class="keyword">on</span> a.id=b.id</span><br><span class="line"><span class="keyword">and</span> a.id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">and</span> b.score&gt;<span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>
<p>查询结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">第一系列</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">第二系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">第三系列</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">第四系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">第五系列</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">其他系列</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>以上查询结果中，首先表a结果全部显示了（on条件中的in条件看起来不生效，实际上是只对表b的关联数据生效），score列数据显示了大于20并且表b中id能与表a中id是（1/2/3）一致的记录。</p>
<h2 id="样例四"><a href="#样例四" class="headerlink" title="样例四"></a>样例四</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.score</span><br><span class="line"><span class="keyword">from</span> tab_a a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab_b b</span><br><span class="line"><span class="keyword">on</span> a.id=b.id</span><br><span class="line"><span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure>
<p>查询结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">其他系列</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>以上查询结果中，只会显示b表id在a表id中找不到的记录，这个方法也通常用来作为比较数据差异的常用逻辑。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化：inner、left join</title>
    <url>/SQL%E4%BC%98%E5%8C%96%EF%BC%9Ainner%20join%E3%80%81left%20join/</url>
    <content><![CDATA[<p>新系统用户基数16万，各种查询timeout。打开砂锅问到底，一大堆in\not in\except肯定不行。这里总结一下，怎么替换掉in\not in\except。</p>
<h3 id="1-in-except-gt-left-join"><a href="#1-in-except-gt-left-join" class="headerlink" title="1. in/except->left join"></a>1. in/except-&gt;left join</h3><h4 id="查询目的："><a href="#查询目的：" class="headerlink" title="查询目的："></a>查询目的：</h4><p>根据</p>
<pre><code>客户表(Customer，按照站点、册本划分，16万数据)

水表表(Meter，16万数据)

水表抄表数据表(Meter_Data，远传表每天更新，27万数据)

关联查询，查询某天某个册本下水表未上传抄表数据的用户。
</code></pre><h4 id="原查询结构"><a href="#原查询结构" class="headerlink" title="原查询结构"></a>原查询结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">cs.Group_No = <span class="string">'册本编号'</span> <span class="keyword">and</span></span><br><span class="line">cs.Customer_No <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> Customer_No </span><br><span class="line">    <span class="keyword">from</span>  Customer cs</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line">    <span class="keyword">where</span> cs.Group_No = <span class="string">'册本编号'</span></span><br><span class="line">    <span class="keyword">except</span></span><br><span class="line">    <span class="keyword">select</span> Customer_No</span><br><span class="line">    <span class="keyword">from</span> Customer cs</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line">    <span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="原查询思路"><a href="#原查询思路" class="headerlink" title="原查询思路"></a>原查询思路</h4><p>查询出目标册本已上传数据的用户编号</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Customer_No</span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line"><span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span></span><br></pre></td></tr></tbody></table></figure>
<p>查询出目标册本全部用户编号</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Customer_No </span><br><span class="line"><span class="keyword">from</span>  Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">where</span> cs.Group_No = <span class="string">'册本编号'</span></span><br></pre></td></tr></tbody></table></figure>
<p>全部用户编号中排除已上传数据的用户编号，即为未上传数据的用户编号</p>
<p>全部用户编号 except 已抄表的用户编号</p>
<p>查询出在未抄表用户编号集合中的用户信息。<br></p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">cs.Group_No = <span class="string">'册本编号'</span> <span class="keyword">and</span></span><br><span class="line">cs.Customer_No <span class="keyword">in</span> </span><br><span class="line">(全部用户编号 <span class="keyword">except</span> 已抄表的用户编号)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>思路倒是没有问题，但是in+except查询效率不要太慢了，本来想测试个时间，结果执行了几分钟愣是没出结果，直接终止掉了。</p>
<h4 id="优化查询结构"><a href="#优化查询结构" class="headerlink" title="优化查询结构"></a>优化查询结构</h4><p>其实in\not in\except这些语法在查询中使用，效率不高是公认的事实，但是可能是由于语义比较明显吧，很多人还是喜欢这样用。我们这里使用left join来替代in+except。这里就来改掉上面的查询：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cs.*</span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line"><span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span> <span class="keyword">and</span> md.meter_no <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="优化查询思路"><a href="#优化查询思路" class="headerlink" title="优化查询思路"></a>优化查询思路</h4><p>用left join代替in+except，通过left join获取目标册本下全部用户的信息，并与当天上传的抄表数据进行连接；</p>
<p>连接中，右表为空即抄表数据为空的，即为当前未上传数据的客户信息；</p>
<p>left join on expression where expression 执行时，首先确保左表数据全部返回，然后应用on后指定的条件。因此，on的条件如果是对左表数据的过滤，是无效的；对右表数据的过滤是有效的。对左表数据的过滤条件，需要放到where条件中。</p>
<h3 id="2-not-in-gt-left-join"><a href="#2-not-in-gt-left-join" class="headerlink" title="2. not in->left join"></a>2. not in-&gt;left join</h3><p>上面in+except的写法，可以使用not in简化一下，但是一样效率不高。这里想要说明的是not in也可以很方便的使用left join替换。</p>
<h4 id="not-in结构"><a href="#not-in结构" class="headerlink" title="not in结构"></a>not in结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">cs.Group_No = <span class="string">'册本编号'</span> <span class="keyword">and</span></span><br><span class="line">cs.Customer_No <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> Customer_No</span><br><span class="line">    <span class="keyword">from</span> Customer cs</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line">    <span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="left-join结构"><a href="#left-join结构" class="headerlink" title="left join结构"></a>left join结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cs.*</span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line"><span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span> <span class="keyword">and</span> md.meter_no <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-in-gt-inner-join"><a href="#3-in-gt-inner-join" class="headerlink" title="3. in->inner join"></a>3. in-&gt;inner join</h3><h4 id="查询目的：-1"><a href="#查询目的：-1" class="headerlink" title="查询目的："></a>查询目的：</h4><p>还是上面的查询背景，这里查询某天某个册本已经上传抄表数据的用户信息。</p>
<h4 id="in结构"><a href="#in结构" class="headerlink" title="in结构"></a>in结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">cs.Group_No = <span class="string">'册本编号'</span> <span class="keyword">and</span></span><br><span class="line">cs.Customer_No <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> Customer_No</span><br><span class="line">    <span class="keyword">from</span> Customer cs</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line">    <span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>这里使用in不够高效，但是我们使用left join是否可以呢？</p>
<h4 id="left-join结构-1"><a href="#left-join结构-1" class="headerlink" title="left join结构"></a>left join结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cs.*</span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line"><span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span> <span class="keyword">and</span> md.meter_no <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>left join结构的话，这里需要使用is not null作为筛选条件。但是is not null同样非常低效。因此我们使用inner join</p>
<h4 id="inner-join结构"><a href="#inner-join结构" class="headerlink" title="inner join结构"></a>inner join结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cs.*</span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line"><span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>inner join通过连接操作，直接获取到已上传抄表数据的用户信息。</p>
<h3 id="4-not-in-gt-in-gt-inner-join"><a href="#4-not-in-gt-in-gt-inner-join" class="headerlink" title="4. not in -> in -> inner join"></a>4. not in -&gt; in -&gt; inner join</h3><p>前面的查询场景中，我们默认的条件是未上传抄表数据的用户，当天在meter_data表是没有记录的。现在假设我们每天凌晨初始化meter_data表，设置抄表数值默认为零，抄表数据上传默认为state=0未上传。上传后，更新抄表数值和抄表状态state=1。</p>
<p>这时，我们来优化上面的not in查询结构还有另外一种思路。</p>
<h4 id="not-in结构-1"><a href="#not-in结构-1" class="headerlink" title="not in结构"></a>not in结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">cs.Group_No = <span class="string">'册本编号'</span> <span class="keyword">and</span></span><br><span class="line">cs.Customer_No <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> Customer_No</span><br><span class="line">    <span class="keyword">from</span> Customer cs</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line">    <span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span> <span class="keyword">and</span> meter.state=<span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="in结构-1"><a href="#in结构-1" class="headerlink" title="in结构"></a>in结构</h4><p>通过筛选条件取反，变换not in-&gt;in<br></p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">cs.Group_No = <span class="string">'册本编号'</span> <span class="keyword">and</span></span><br><span class="line">cs.Customer_No <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> Customer_No</span><br><span class="line">    <span class="keyword">from</span> Customer cs</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line">    <span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span> <span class="keyword">and</span> meter.state=<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="inner-join结构-1"><a href="#inner-join结构-1" class="headerlink" title="inner join结构"></a>inner join结构</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cs.*</span><br><span class="line"><span class="keyword">from</span> Customer cs</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Meter me <span class="keyword">on</span> cs.Customer_No = me.Customer_No</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Meter_data md <span class="keyword">on</span> me.meter_no = md.meter_no <span class="keyword">and</span> md.date = <span class="string">'2019-04-09'</span></span><br><span class="line"><span class="keyword">where</span> cs.Group_NO=<span class="string">'册本编号'</span> <span class="keyword">and</span> meter.state=<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-总结如下"><a href="#5-总结如下" class="headerlink" title="5. 总结如下"></a>5. 总结如下</h3><p>上面的查询结构拆分出来后，大家可能觉得这么简单的sql怎么可能写成这个沙雕。其实真实业务系统，还有关联其他将近10张表。这里想说的是，在in\not in\except这种查询结构时，如果涉及到的数据量较大，建议坚决用连接替换。</p>
<p>… in (all except sub)… 查询结构可以转换为-&gt;left join</p>
<p>… not in … 查询结构可以转换为-&gt;left join</p>
<p>… not in … 查询也可以转换为 in -&gt; inner join，这里需要确认转换查询条件时，是否有对应的数据</p>
<p>… in 查询结构可以转换为-&gt;inner join</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC核心（一）：核心业务流程</title>
    <url>/SpringMVC%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><p>Spring MVC 融合在 Spring Web Flow 里面。 使用 Spring 可插入的 <code>MVC</code> 架构，可以选择是使用内置的 Spring Web 框架还是 Struts 这样的 Web框架，MVC 已经是现代Web开发中的一个很重要的部分。与许多其他Web框架一样，Spring MVC围绕前端控制器模式设计，其中中央 Servlet DispatcherServlet 为请求处理提供共享算法，而实际工作由可配置委托组件执行。该模型非常灵活，支持多种工作流程。<br>Spring+SpringMVC开发的时候配置文件一般有 <code>web.xml</code>（必须）<br>必须的原因在于：配置<code>contexLoadListener</code>，配置<code>DispatcherServlet</code>拦截请求 </p>
<p><strong> 解析：</strong></p>
<ol>
<li><p>MVC架构模式的思想：将Web层进行指责解耦</p>
</li>
<li><p>基于请求驱动：请求-相应模型</p>
</li>
<li><p>框架的目的：简化开发</p>
</li>
</ol>
<p><strong>SpringMVC的痛痒点有三个:</strong></p>
<p>（1）将Web页面的请求传给服务器 </p>
<p>（2）根据不同的请求处理不同的逻辑页面 </p>
<p>（3）返回处理结果数据并跳转页面 </p>
<h1 id="springMVC核心业务流程"><a href="#springMVC核心业务流程" class="headerlink" title="springMVC核心业务流程"></a>springMVC核心业务流程</h1><p>上面说的<code>其中中央Servlet DispatcherServlet为请求处理提供共享算法，而实际工作由可配置委托组件执行</code> 我们来用图例看一下：</p>
<p><img src="/uploads/SpringMVC核心/SpringMVC核心流程.jpg" alt="SpringMVC核心流程" title="SpringMVC核心流程"></p>
<p><strong>具体步骤：</strong></p>
<ol>
<li><p>首先用户发送请求—&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
</li>
<li><p>DispatcherServlet—&gt;HandlerMapping，它将会把请求映射为 HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</p>
</li>
<li><p>DispatcherServlet—&gt;HandlerAdapter，它将会把处理器包装为适配器，从而支持多种类型的处理器，即<code>适配器设计模式</code>的应用，从而很容易支持很多类型的处理器；</p>
</li>
<li><p>HandlerAdapter—&gt;处理器功能处理方法的调用，它将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理（处理器在这里进行拦截器的处理、异常处理器的处理等等）；并返回一个 ModelAndView 对象（包含模型数据、逻辑视图名）；</p>
</li>
<li><p>ModelAndView 的逻辑视图名—&gt; ViewResolver， 它将把逻辑视图名解析为具体的 View，通过这种策略模式，很容易更换其他视图技术；</p>
</li>
<li><p>View—&gt;渲染，它会根据传进来的 Model 模型数据进行渲染，此处的 Model 实际是一个 Map 数据结构，因此很容易支持其他视图技术；</p>
</li>
<li><p>返回控制权给 DispatcherServlet，由 DispatcherServlet 返回响应给用户，到此一个流程结束。（声明:图中的View指向用户只是单纯方便理解）</p>
</li>
</ol>
<hr>
<h1 id="组件名词解释"><a href="#组件名词解释" class="headerlink" title="组件名词解释"></a>组件名词解释</h1><ol>
<li>DispatcherServlet: 前端控制器</li>
</ol>
<p>等同于以前的Controller， 是整个流程的中心， 负责调用其他组件。<br>前端控制器（DispatcherServlet）：这个是 SpringMVC的入口（实际上呢就是一个Servlet对象），所有的请求都要通过它，因为是个Servlet所以不可避免的你要在web.xml进行配置。</p>
<ol start="2">
<li>HandlerMapping： 处理器映射器</li>
</ol>
<p>负责根据请求找到Handler（处理器），springMVC中可以根据不同的映射器实现不同映射，比如 xml配置方式，注解方式，接口方式等。<br>处理器映射器(HandlerMapper)，这个就是根据不同的方式找到处理器（Handler），它支持的有配置文件形式，接口形式，注解形式等等。</p>
<ol start="3">
<li>HandlerAdapter：处理器适配器</li>
</ol>
<p>处理Handler，可以对多种类型的处理器进行执行，这是对适配器模式的应用体现。<br>处理器适配器（HandlAdapter）这个就是分析处理器是那种方式的处理器（配置文件，接口、注解等形式）然后执行Handler。</p>
<ol start="4">
<li>Handler：后端控制器</li>
</ol>
<p>在前端控制器的控制下对具体的用户请求进行处理，所以一般情况下都需要开发者进行根据需求进行开发。</p>
<ol start="5">
<li>ViewResolver: 视图解析器</li>
</ol>
<p>负责将处理结果生成view视图、开发者可以根据需要开发view;SpringMVC提供了很多视图，比如jstlView、freemarkerView、pdfView（<code>后面更新</code>）等。</p>
<blockquote>
<p>SpringMVC中的三大组件分别是：前端控制器，处理器映射器，视图解析器；用户需要开发的部件是：Handler和view</p>
</blockquote>
<blockquote>
<p>ModelAndView 封装了数据和视图信息，如果想进行页面的数据交互，可以选择这个是进行传输，数据的存放位置，默认的是Request域。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read.">
    <label for="pass">Please enter the password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX187s+QXQckR1ZFFRdORNvveXduXkIXQ0CuxFLW+DtAa1gge96V+T1jjX3CTmJXbfQcNNzmnJuUV5Wipuuu3eH+IWymL94lpqDz/2Wu01GTFVmqZx3udEDt1D06+uw6AV/bHBvJ/CQG3D/aGdrHp8lKo+DQj454vaI4AsVznRwDUuXkwJg8fQsmuENCrOpLYq1il3KiJThXdB03lNF7zZ2jZfXR0EJ9KzmM0nElsE8Z5IVE7OnSAmPv2WA7NNVDJ5DENh3HN1rWH/pwAxB/4QYyeUgPSpiZyXoltIE57aSfR9nRIbPD4y4yCjlcaHclW4bXGBc85cMd3JT/eYScIP5a2qVWOcw4Nkm2RLvdNpv8l3pME0q+76T2do4Y/t55Ar3ccfqbxvYL3fvoQ8ucchdMSEoraNXVQapId+slGem4IpuIXPhRFyEhpX/YZUNdUdXv8pbP6dukZtj8WWLlBFD3EcAyqoVgOfSiJqXVMi5yp1GINe8vTS5ggcibaEoew0o7+VQx+kW6MPFy2OO6JqxI3TG/8hB1pOTyQP4Rm9gYIDUSCqCIJNSX7Wi6tomouk9SOSO7h2UE7Wra913VsbbsJQ0rRhap1ORen8Qd7eJnWyPFpxO/qOeSojr/1NQ6iyhbwEGHfiPogxFLVrSwHLKd+py/bBlW9bWG2+NClpZUKzARzC1TqCzU826oB+KLo0B7DuxtQOgwa4xEzz8meR1hGsA2wmts1OpFpl5LqdeZ8LJO2qA5FPQFVQv2z2Z2E/PEfX+tJ5W2dPH4NI3x7ndqEZeQlcY8y43MTOgXzdw9mhLjMZuc0NxKltMXjA1k9WHboK6DMnAguL+jz5lSEBeDGa9sMxeowlWcHTxj4cTW2h2vu5Nk5BRcZZbFyJTtybQR9orTOYqES9vWO+3f6a/zgEdIJ6QG0UsbWK0v9QkJ5CmFQrHePObMuG0r77t7iNdQv1vsge8deqxd/O1D1O0YxxCoGDxGSOi8BVazFNfSOIm59RNJF+9wq0ZPJLoW0rvb0Fl/zSHIjannBaOU0D5/RH+6WuTvmoUKA/8l6BcIMi7UAVJ2zJN6zZBRtjQbEv7nUmHBY8Q5PaeamlrijVa6AKG6QxqJwsMQ6rrca4azlPAb1ruWmxnVh/QWnBGWOHuKGGDs8CL/bcl5nr1zrTMsnNhOdEnRrBZuOI16ZpkpiDZpnypTIXlAvCUQY3aOoMwI3TdZiGefuU01fqQq+KOmDaWZypNKfwgXrRgE8k3qY7611MTyVRkIXSGLWKi6idHK36BjUkVunwqsVGnolr1BX/AWoMuReBoPnrc2cBsx3yLIwUpXGYKWGvaoxl6Jemc11XtLgjrzJL2tX5yNaR8k48K+9SrCCdJ2eZ1i0FrTieo84o9PCAu57wC6GAuK2dJlCRN5LiOaRLyplL7UpZ9DU0VZhbR0ZpUMtpRiepS982RU5noixNNKxxHNJvBjXADe07o5g8chkI+sS3YCmL2OQgH0DWIXTtMDuftnp6m3RZPj2dOXYzjtzlW8PXsX2PKfY5erLQL5iypkes7hGg5WtdJGEwFifQ7SDi4ryYAYlCPO4KCMWy3BqgqMZkKSIgKKb4EUav010ugo3eLS559ObnBm/SBsJSfriusz/6IZJiT54zPzhUpD+lixTREyyP7oYOS+SsDklZC1IasIQUo8IWj1H2sEAXmj1SDmPfjY0UBRaU8f3G7R38b1T515QWkt8j9EX6WQix+d7iQBaBkyFoxL1UQyeuZTQgZQOnhtT4HGg5pIBoBU27L5hUHb56xhXlhkhRtbN8biQkpqqkqq/x5Rn2JyPDPwNFnbzApW+XzKVb9M/UtBeX/qy3Jr34u1QcjSNGANqSNRT7mQJX66Y4IFA7sICF4ttmxonBZCbgvpgi6cWAsgF2IYMcxbUeEK4tcViYvmr8u0Qx/XGBPnrkrY5xN4mGKu2qg0K8MUbg3DKH28IkjdfFrFz/ZzGRptZkCg1gzEoAq4m5L8OVyKofjeL3SpDpo/UnMbf8DUmop3SBYPAxi0YrGRzlRyuFq53unD5lzfAvo5XqJPsCMZf2l9pSjLGSg4S6pPCy0cvmNDgqiiSSaDl+LK9CYowBBrQ35a+iNnGFChDTFGb9igtOccLY5t5tr8PgavBr6xxuX7kmVgFWMZd03ykkLdRi+W8CoXmtQsGEGBUX7L+ushRi6CbZbVMBKar0zENZB2XuTvouanugBFZQYa/Wv7GG9HdnmDIrix9driOB5rUILrATk29k3yOyzXzlcMiCTn3OUkkjakoxbxSE34yMGAaengt1nTO3RxnlLdDlZQkjo1T8pPEmVHbk3pUZXSfgSSCnwSTpVjm8ciJTgTN+/syX2onTdrP6DFJXEfDJVM1qfOQdNsck2SbMGhUsEY6DKtvWXAaYdl1SSkqjQFq8ZT8LNPCAjxmKIpNOZz02s42qTAQh23aDm6jHoSkXPVKLmzyCgf/T3UEmujWKkBlgP/51BJNhVZs0uADm6slb1h6faWonPanOGm+mdD4AWqyP3pf6/jE6C+Sv8YVZnfg3EZyNOYwI4ECIeC2iid9rY1f5R3F2qSv7iDf/ie4i78MoGrkyb4E8amuvTfnqNSvvKdAEhJlhOOnv2CmaWDNJ+hX/TViLaz74EH2zdkYsC5wGpH/uuMXwhbXHO5Vt2LkW8xnp9wz1NWteClrbBrYrK1Xapq/kA4VruvLnp7sQIEAYnHNgI/d+olgeGQ11awXTxGZy5LLXe7kjgsfzMMUIqoR/AKkhbqnQh659DL54Qt4NG17QOC33oOekWSP/+0Sxdi8NkkQyqCnelq0GWgS6Mss+4B21hsUdD/7aFLrxtpgo68ye8Te4Oawr0NVnVA+q0M8SOaUfwPK7hwWpND79250teRqwHMVgngfcjkt0gBQ++vpB1liCN/9NXElFX2kcgW6u4f1INNCJ4JPGQn8xGnm3i25O55rxt3zDeDjEtNE6CpcvtqUzUh0JEbmNM+Dui/DjNObIfsitdl1QQdqOIXznbnhJZ7jfAWsbpXU8I1vy3ztl43V6WuNtSnxJd3HgqoKwennzEtLfMV2ft+NZ4MmO3Lq3I6379Hor05IHJ4vC1kD9mGAXAXATDabT0JYpb0hqxMJKY/vFlv+RA==
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css"><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li><p>手机号验证</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">^((<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>])|(<span class="number">14</span>[<span class="number">5</span><span class="number">-9</span>])|(<span class="number">15</span>([<span class="number">0</span><span class="number">-3</span>]|[<span class="number">5</span><span class="number">-9</span>]))|(<span class="number">16</span>[<span class="number">6</span><span class="number">-7</span>])|(<span class="number">17</span>[<span class="number">1</span><span class="number">-8</span>])|(<span class="number">18</span>[<span class="number">0</span><span class="number">-9</span>])|(<span class="number">19</span>[<span class="number">1</span>|<span class="number">3</span>])|(<span class="number">19</span>[<span class="number">5</span>|<span class="number">6</span>])|(<span class="number">19</span>[<span class="number">8</span>|<span class="number">9</span>]))\\d{<span class="number">8</span>}$</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>emjoy验证</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">[\ud83c\udc00-\ud83c\udfff]|[\ud83d\udc00-\ud83d\udfff]|[\ud83e\udd00-\ud83e\udfff]|[\u2600-\u27ff]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>中文验证</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]{<span class="number">0</span>,}$</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>邮箱地址验证</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>全角字符验证</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">/[\uFF00-\uFFFF]/</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>强密码验证(必须包含大小写字母/数字/特殊字符的组合，长度在8-10之间)：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">^(?![<span class="number">0</span><span class="number">-9</span>]+$)(?![^<span class="number">0</span><span class="number">-9</span>]+$)(?![a-z]+$)(?![^a-z]+$)(?![A-Z]+$)(?![^A-Z]+$)(?![a-zA-Z0<span class="number">-9</span>]+$)[a-zA-Z0<span class="number">-9</span>\S]{<span class="number">8</span>,<span class="number">10</span>}$</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>15位或18位身份证号验证</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">(^([<span class="number">1</span><span class="number">-6</span>][<span class="number">1</span><span class="number">-9</span>]|<span class="number">50</span>)\d{<span class="number">4</span>}(<span class="number">18</span>|<span class="number">19</span>|<span class="number">20</span>)\d{<span class="number">2</span>}((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|<span class="number">10</span>|<span class="number">11</span>|<span class="number">12</span>)(([<span class="number">0</span><span class="number">-2</span>][<span class="number">1</span><span class="number">-9</span>])|<span class="number">10</span>|<span class="number">20</span>|<span class="number">30</span>|<span class="number">31</span>)\d{<span class="number">3</span>}[<span class="number">0</span><span class="number">-9</span>Xx]$)|(^([<span class="number">1</span><span class="number">-6</span>][<span class="number">1</span><span class="number">-9</span>]|<span class="number">50</span>)\d{<span class="number">4</span>}\d{<span class="number">2</span>}((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|<span class="number">10</span>|<span class="number">11</span>|<span class="number">12</span>)(([<span class="number">0</span><span class="number">-2</span>][<span class="number">1</span><span class="number">-9</span>])|<span class="number">10</span>|<span class="number">20</span>|<span class="number">30</span>|<span class="number">31</span>)\d{<span class="number">3</span>}$)</span><br></pre></td></tr></tbody></table></figure>
<p> &nbsp;<br> &nbsp;</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 15位身份证号转18位身份证号mysql函数 --&gt;</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">FUNCTION</span> <span class="string">`idcard_15to18`</span>(<span class="string">`idcard`</span> <span class="built_in">varchar</span>(<span class="number">32</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> v_sum <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> v_mod <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i_flag <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span>  i_card <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">SET</span> idcard = <span class="keyword">REPLACE</span>(idcard,<span class="string">' '</span>,<span class="string">''</span>);</span><br><span class="line">    IF LENGTH(idcard) &lt;&gt; 15 THEN</span><br><span class="line">    RETURN NULL;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">SET</span> idcard = <span class="keyword">CONCAT</span>(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">1</span>,<span class="number">6</span>),<span class="string">'19'</span>,<span class="keyword">SUBSTRING</span>(idcard,<span class="number">7</span>,<span class="number">9</span>));</span><br><span class="line">    <span class="keyword">SET</span> v_sum=(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">1</span>,<span class="number">1</span>)*<span class="number">7</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">2</span>,<span class="number">1</span>)*<span class="number">9</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">3</span>,<span class="number">1</span>)*<span class="number">10</span>)+</span><br><span class="line">    (<span class="keyword">SUBSTRING</span>(idcard,<span class="number">4</span>,<span class="number">1</span>)*<span class="number">5</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">5</span>,<span class="number">1</span>)*<span class="number">8</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">6</span>,<span class="number">1</span>)*<span class="number">4</span>)+</span><br><span class="line">    (<span class="keyword">SUBSTRING</span>(idcard,<span class="number">7</span>,<span class="number">1</span>)*<span class="number">2</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">8</span>,<span class="number">1</span>)*<span class="number">1</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">9</span>,<span class="number">1</span>)*<span class="number">6</span>)+</span><br><span class="line">    (<span class="keyword">SUBSTRING</span>(idcard,<span class="number">10</span>,<span class="number">1</span>)*<span class="number">3</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">11</span>,<span class="number">1</span>)*<span class="number">7</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">12</span>,<span class="number">1</span>)*<span class="number">9</span>)+</span><br><span class="line">    (<span class="keyword">SUBSTRING</span>(idcard,<span class="number">13</span>,<span class="number">1</span>)*<span class="number">10</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">14</span>,<span class="number">1</span>)*<span class="number">5</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">15</span>,<span class="number">1</span>)*<span class="number">8</span>)+</span><br><span class="line">    (<span class="keyword">SUBSTRING</span>(idcard,<span class="number">16</span>,<span class="number">1</span>)*<span class="number">4</span>)+(<span class="keyword">SUBSTRING</span>(idcard,<span class="number">17</span>,<span class="number">1</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">SET</span> v_mod=v_sum%<span class="number">11</span>;</span><br><span class="line">    IF v_mod = 0 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 1 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 2 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 3 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'9'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 4 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'8'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 5 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'7'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 6 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'6'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 7 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'5'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 8 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'4'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 9 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'3'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF v_mod = 10 THEN</span><br><span class="line">        <span class="keyword">SET</span> i_flag = <span class="string">'2'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">SET</span> i_card = <span class="keyword">CONCAT</span>(idcard,i_flag);</span><br><span class="line">    RETURN i_card;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">&lt;!-- Excel公式转18位身份证号 --&gt;</span><br><span class="line">=IF(LEN(A1)=15,<span class="keyword">REPLACE</span>(A1,<span class="number">7</span>,,<span class="number">19</span>)&amp;<span class="keyword">MID</span>(<span class="string">"10X98765432"</span>,<span class="keyword">MOD</span>(<span class="keyword">SUM</span>(<span class="keyword">MID</span>(REPLAC E(A1,<span class="number">7</span>,,<span class="number">19</span>),<span class="keyword">ROW</span>(INDIRECT(<span class="string">"1:17"</span>)),<span class="number">1</span>)*<span class="number">2</span>^(<span class="number">18</span>-<span class="keyword">ROW</span>(INDIRECT(<span class="string">"1:17"</span>)))),<span class="number">11</span> )+<span class="number">1</span>,<span class="number">1</span>),A1)</span><br></pre></td></tr></tbody></table></figure>
<p> &nbsp;<br> &nbsp;</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Regex</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>淘宝会员通疑问总结</title>
    <url>/%E6%B7%98%E5%AE%9D%E4%BC%9A%E5%91%98%E9%80%9A%E7%96%91%E9%97%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><p>隐私改造后怎么做订单匹配转换积分？<br>用<code>taobao.trade.simple.get</code>接口来获取订单，<code>ouid</code>/<code>omid</code>匹配用户订单转换积分。</p>
</li>
<li><p><code>taobao.trade.simple.get</code>怎么获取该订单接口权限<br>只有客户关系管理类目（开放平台控制台自己看下应用类目）才能获取这个接口权限，只有这个应用这个接口才能拿到订单的<code>ouid</code>，其他都不行。（<code>taobao.trade.fullinfo.get</code>（获取单笔交易的详细信息）不在会员通这边，相关问题找开放平台提工单）。</p>
</li>
<li><p>有没有其他方法来获取订单的<code>ouid</code><br>暂时没有方案，没有客户关系管理类目无法匹配订单<code>ouid</code>，建议等待方案（不确定时间）。</p>
</li>
<li><p><code>taobao.crm.member.ouid.get</code>  会员Nick转<code>ouid</code>接口什么时候收回是不是9月28号<br>没有具体通知收回时间，收回前肯定会统一通知。</p>
</li>
<li><p><code>taobao.crm.member.ouid.get</code>  会员Nick转<code>ouid</code>接口QPS限制是多少<br>大约300QPS，不支持大QPS。</p>
</li>
<li><p><code>taobao.crm.member.ouid.get</code>  会员Nick转<code>ouid</code>接口获取不到<code>ouid</code><br>检查该会员是不是会员通入会，不是该店铺会员通会员或者已退会的则无法转换（历史会员不支持）。</p>
</li>
<li><p><code>taobao.crm.member.ouid.get</code>  会员Nick转<code>ouid</code>接口没有权限怎么办<br>对接的会员通相关应用默认都有权限，如果调用SDK无权限，请在应用后台刷新SDK重新下载。</p>
</li>
<li><p>无法获取<code>omid</code><br>检查对应店铺是不是入驻了ebnp平台做了店铺关联，绑定类型是否是直属。都确认了，等待第二天查看。</p>
</li>
<li><p><code>omid</code>区分大小写么<br>会区分，相同的字符串，大小写不同就是两个人。<br><strong>数据存储时注意需要设置大小写敏感</strong></p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>淘宝会员通</tag>
        <tag>OMID</tag>
        <tag>OUID</tag>
      </tags>
  </entry>
  <entry>
    <title>Azkaban任务维护归纳</title>
    <url>/Azkaban%E4%BB%BB%E5%8A%A1%E7%BB%B4%E6%8A%A4%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://azkaban.github.io" target="_blank" rel="noopener">Azkaban官网</a><br>Azkaban是常见的定时任务管理器（分布式工作流管理器），大多数的定时ETL处理任务都会用到。</p>
<h3 id="Azkaban-配置方面"><a href="#Azkaban-配置方面" class="headerlink" title="Azkaban 配置方面"></a>Azkaban 配置方面</h3><ol>
<li>Azkaban默认的最大并发线程数为25，最大同时执行25个flow；可以通过<code>jetty.maxThreads</code>来合理配置Azkaban可以同时进行的任务数量。<strong>修改时需注意每个job初始内存/最大内存的配置</strong></li>
<li>Azkaban默认没有限制任务创建权限，为方便管理一般需要开启<code>lockdown.create.projects</code>来合理分配拥有<code>admin</code>账户的团队。</li>
<li>Azkaban执行日志默认会保留12周的时间，可以通过<code>execution.logs.retention.ms</code>来调整合理的日志留存时间，以毫秒为单位。</li>
</ol>
<h3 id="Azkaban-定时Cron表达式"><a href="#Azkaban-定时Cron表达式" class="headerlink" title="Azkaban 定时Cron表达式"></a>Azkaban 定时Cron表达式</h3><p>Azkaban支持的Cron表达格式：<code>Minutes Hours DayofMonth Month DayofWeek</code></p>
<p><img src="/uploads/Azkaban/flexible-scheduling.png" alt="Azkaban定时调度配置图" title="Azkaban定时调度配置图"></p>
<h4 id="Cron表达式支持的符号"><a href="#Cron表达式支持的符号" class="headerlink" title="Cron表达式支持的符号"></a>Cron表达式支持的符号</h4><ul>
<li><code>*</code> 表示所有值</li>
<li><code>?</code> 表示未说明的值，即不关心它为何值；只能用在DayofMonth和DayofWeek两个域<ul>
<li>它也匹配域的任意值，但实际不会；因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法：<code>13 13 15 20 * ?</code>, 其中最后一位只能用 <code>？</code>，而不能使用 <code>*</code>，如果使用*表示不管星期几都会触发，实际上并不是这样。</li>
</ul>
</li>
<li><code>-</code> 表示一个指定的范围<ul>
<li>例如：在Minutes域使用 <code>5-20</code>，表示从5分到20分钟每分钟触发一次。</li>
</ul>
</li>
<li><code>,</code> 表示列出枚举值<ul>
<li>例如：在Minutes域使用 <code>5,20</code>，则意味着在5和20分每分钟触发一次。</li>
</ul>
</li>
<li><code>/</code> 符号前表示开始时间，符号后表示每次递增的值<ul>
<li>起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用 <code>5/20</code>,则意味着从5分开始每20分钟触发一次 <code>00:05 00:25 00:45 01:05</code>。</li>
</ul>
</li>
<li><code>L</code>(last)<ul>
<li>用在day-of-month中意思是 “这个月最后一天”；用在 day-of-week中意思是 <code>7</code> 或者 <code>SAT</code>。</li>
<li>如果在day-of-week字段里和数字联合使用，它的意思就是 “这个月的最后一个星期几”；例如： <code>6L</code> 意思是这个月的最后一个星期五。</li>
<li><strong>注意</strong>：最后当我们用<code>L</code>时，不指明一个列表值或者范围是很重要的，不然的话会导致逻辑问题。</li>
</ul>
</li>
<li><code>W</code>(weekday) 只能用在day-of-month字段,用来描叙最接近指定天的工作日（周一到周五）<ul>
<li>在day-of-month字段用<code>15W</code>指 “最接近这个月第15天的工作日”；即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第16天即周一触发；如果这个月第15天是周二，那么就在触发器周二这天触发。</li>
<li><strong>注意</strong>：这个用法只会在当前月计算值，不会越过当前月；<code>W</code>字符仅能在 day-of-month指明一天，不能是一个范围或列表；也可以用<code>LW</code>来指定这个月的最后一个工作日。</li>
</ul>
</li>
<li><code>#</code> 只能用在day-of-week字段，用来指定这个月的第几个周几<ul>
<li>在day-of-week字段用<code>6#3</code>指这个月第3个周五（6指周五，3指第3个）。</li>
<li><strong>注意</strong>：如果指定的日期不存在，触发器就不会触发。</li>
</ul>
</li>
<li><code>C</code> 指和calendar联系后计算过的值<ul>
<li>在day-of-month 字段用<code>5C</code>指在这个月第5天或之后包括calendar的第一天；在day-of-week字段用<code>1C</code>指在这周日或之后包括calendar的第一天。</li>
</ul>
</li>
</ul>
<h4 id="域取值"><a href="#域取值" class="headerlink" title="域取值"></a>域取值</h4><p>下表为Cron表达式中六个域能够取的值以及支持的特殊字符。</p>
<table>
<thead>
<tr>
<th>域</th>
<th>是否必需</th>
<th>取值范围</th>
<th>特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒</td>
<td>是</td>
<td>[0, 59]</td>
<td>* , - /</td>
</tr>
<tr>
<td>分钟</td>
<td>是</td>
<td>[0, 59]</td>
<td>* , - /</td>
</tr>
<tr>
<td>小时</td>
<td>是</td>
<td>[0, 23]</td>
<td>* , - /</td>
</tr>
<tr>
<td>日期</td>
<td>是</td>
<td>[1, 31]</td>
<td>* , - / ? L W</td>
</tr>
<tr>
<td>月份</td>
<td>是</td>
<td>[1, 12]或[JAN, DEC]</td>
<td>* , - /</td>
</tr>
<tr>
<td>星期</td>
<td>是</td>
<td>[1, 7]或[MON, SUN]。若您使用[1, 7]表达方式，1代表星期一，7代表星期日</td>
<td>* , - / ? L #</td>
</tr>
<tr>
<td>年</td>
<td>否</td>
<td>[当前年份，2099]</td>
<td>* , - /</td>
</tr>
</tbody>
</table>
<h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a><strong>e.g.</strong></h4><p>corn表达式结构从左到右（用空格隔开）：<code>秒 分 小时 月份中的日期 月份 星期中的日期 年份</code><br><code>0 */1 * * * ?</code> 每隔1分钟执行一次<br><code>30 10 1 * * ?</code> 每天1点10分30秒触发任务<br><code>0 0 23 L * ?</code> 每月最后一天23点执行一次</p>
<h3 id="Azkaban-API自动化应用"><a href="#Azkaban-API自动化应用" class="headerlink" title="Azkaban API自动化应用"></a>Azkaban API自动化应用</h3><p>Azkaban 有一些公开的 ajax 调用，可通过 curl 或其他一些 HTTP 请求客户端访问。</p>
<h4 id="自动化第一步"><a href="#自动化第一步" class="headerlink" title="自动化第一步"></a>自动化第一步</h4><p>直接抄官网的话：应该为几乎所有 API 调用（身份验证除外）提供 <code>session.id</code>。 <code>session.id</code> 可以简单地附加为请求参数之一，或通过 cookie 设置：<code>azkaban.browser.session.id</code>。下面的两个 HTTP 请求是等价的：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># a) 直接提供 `seeeion.id` 参数</span></span><br><span class="line">curl -k --get --data <span class="string">"session.id=bca1d75d-6bae-4163-a5b0-378a7d7b5a91&amp;ajax=fetchflowgraph&amp;project=azkaban-test-project&amp;flow=test"</span> https://localhost:8443/manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># b) 提供cookie `azkaban.browser.session.id`</span></span><br><span class="line">curl -k --get -b <span class="string">"azkaban.browser.session.id=bca1d75d-6bae-4163-a5b0-378a7d7b5a91"</span> --data <span class="string">"ajax=fetchflowgraph&amp;project=azkaban-test-project&amp;flow=test"</span> https://localhost:8443/manager</span><br></pre></td></tr></tbody></table></figure>
<p>All API calls require a proper authentication first.（所有API访问首先需要获取正确的身份授权[session|cookie 等价]）。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 请求身份授权信息</span></span><br><span class="line">curl -k -X POST --data <span class="string">"action=login&amp;username=azkaban&amp;password=azkaban"</span> https://localhost:8443</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">// 身份授权信息获取成功</span><br><span class="line">{</span><br><span class="line"><span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line"><span class="attr">"session.id"</span> : <span class="string">"c001aba5-a90f-4daf-8f11-62330d034c0a"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>&nbsp;<br>&nbsp;</p>
<h4 id="自动化应用实例"><a href="#自动化应用实例" class="headerlink" title="自动化应用实例"></a>自动化应用实例</h4><p><strong>自动化应用就是把这些公开的API接口通过其他程序或脚本缝合在一起，完成需求的实现。</strong></p>
<h5 id="一键部署应用"><a href="#一键部署应用" class="headerlink" title="一键部署应用"></a>一键部署应用</h5><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Variables</span></span><br><span class="line">application=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">project=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line">env=<span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load config properties</span></span><br><span class="line">work_dir=$(</span><br><span class="line">  <span class="built_in">cd</span> <span class="string">"<span class="variable">$(dirname "$0")</span>"</span></span><br><span class="line">  <span class="built_in">pwd</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">source</span> <span class="string">"<span class="variable">${work_dir}</span>"</span>/<span class="string">"<span class="variable">${env}</span>"</span>.env</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcheck disable=SC2076</span></span><br><span class="line"><span class="comment"># shellcheck disable=SC2049</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">${application}</span>"</span> =~ <span class="string">'/'</span> ]] || [[ <span class="string">"<span class="variable">${application}</span>"</span> =~ <span class="string">'*'</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Project name contains illegal character!'</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build azkaban project, step like below:</span></span><br><span class="line"><span class="comment">#   1. remove orgin project dir.</span></span><br><span class="line"><span class="comment">#   2. remove orign project azkaban zip.</span></span><br><span class="line"><span class="comment">#   3. copy project dir from application to deploy dir.</span></span><br><span class="line"><span class="comment">#   4. consutruct azkaban zip from new project dir.</span></span><br><span class="line"><span class="comment"># shellcheck disable=SC2115</span></span><br><span class="line">project_path=<span class="string">"<span class="variable">${dir}</span>/<span class="variable">${application}</span>-<span class="variable">${env}</span>/azkaban/<span class="variable">${project}</span>"</span></span><br><span class="line">project_deploy_path=<span class="string">"<span class="variable">${application}</span>/<span class="variable">${project}</span>/<span class="variable">${project}</span>"</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">${project_deploy_path}</span>"</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">${project_deploy_path}</span>.zip"</span></span><br><span class="line">cp -r <span class="string">"<span class="variable">${project_path}</span>"</span> <span class="string">"<span class="variable">${project_deploy_path}</span>"</span></span><br><span class="line">zip -r <span class="string">"<span class="variable">${project_deploy_path}</span>"</span>.zip <span class="string">"<span class="variable">${project_deploy_path}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply for session_id from server</span></span><br><span class="line">login_response=$(curl -s -k -X POST --data <span class="string">"action=login&amp;username=<span class="variable">${username}</span>&amp;password=<span class="variable">${password}</span>"</span> <span class="string">"<span class="variable">${host}</span>"</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$login_response</span>"</span> =~ <span class="string">"error"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Login failure &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Login response: <span class="variable">${login_response}</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$login_response</span>"</span> =~ <span class="string">"success"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Login success &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span></span><br><span class="line">  session_id=$(python -c <span class="string">"import json,sys; data = json.dumps(<span class="variable">${login_response}</span>);data = json.loads(data); print (data['session.id']);"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Applied session_id: <span class="variable">${session_id}</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Upload project</span></span><br><span class="line">upload_response=$(curl -i -k -H <span class="string">'Content-Type: multipart/mixed'</span> -X POST --form <span class="string">"session.id=<span class="variable">${session_id}</span>"</span> --form <span class="string">'ajax=upload'</span> --form <span class="string">"file=@<span class="variable">${project_deploy_path}</span>.zip;type=application/zip"</span> --form <span class="string">"project=<span class="variable">${project}</span>"</span> <span class="string">"<span class="variable">${host}</span>"</span>/manager)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Upload response: <span class="variable">${upload_response}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schedule func</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">schedule</span></span>() {</span><br><span class="line">  <span class="built_in">local</span> flow=<span class="variable">$1</span></span><br><span class="line">  <span class="built_in">local</span> cronExpression=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Start schedule the flow <span class="variable">${flow}</span> of project <span class="variable">${project}</span>, cronExpression: <span class="variable">${cronExpression}</span>"</span></span><br><span class="line">  <span class="built_in">local</span> schedule_response</span><br><span class="line">  schedule_response=$(curl -k -d <span class="string">"ajax=scheduleCronFlow"</span> -d <span class="string">"projectName=<span class="variable">${project}</span>"</span> -d <span class="string">"flow=<span class="variable">${flow//\"/}</span>"</span> --data-urlencode <span class="string">"cronExpression=<span class="variable">${cronExpression//\"/}</span>"</span> -b <span class="string">"azkaban.browser.session.id=<span class="variable">${session_id}</span>"</span> <span class="string">"<span class="variable">${host}</span>"</span>/schedule)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Schedule response: <span class="variable">${schedule_response}</span>"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># Schedule</span></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="string">"<span class="variable">${project_deploy_path}</span>-schedule.csv"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">    flow=$(awk <span class="string">'BEGIN{split(ARGV[1],var,";");print var[1]}'</span> <span class="string">"<span class="variable">${line}</span>"</span>)</span><br><span class="line">    cronExpression=$(awk <span class="string">'BEGIN{split(ARGV[1],var,";");print var[2]}'</span> <span class="string">"<span class="variable">${line}</span>"</span>)</span><br><span class="line">    schedule <span class="string">"<span class="variable">${flow}</span>"</span> <span class="string">"<span class="variable">${cronExpression}</span>"</span></span><br><span class="line">  <span class="keyword">done</span> &lt;<span class="string">"<span class="variable">${project_deploy_path}</span>-schedule.csv"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Deploy success &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span></span><br></pre></td></tr></tbody></table></figure>
<p>&nbsp;<br>&nbsp;</p>
<h5 id="实时接口ETL联动应用"><a href="#实时接口ETL联动应用" class="headerlink" title="实时接口ETL联动应用"></a>实时接口ETL联动应用</h5><p>代码太多，持续更新中….</p>
<p>&nbsp;<br>&nbsp;</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Azkaban</tag>
        <tag>Workflow Manager</tag>
        <tag>Cron</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive窗口分析函数</title>
    <url>/Hive%E7%AA%97%E5%8F%A3%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="常见分析函数"><a href="#常见分析函数" class="headerlink" title="常见分析函数"></a>常见分析函数</h3><ul>
<li>Aggregate Functions: 聚合函数,比如：sum(…)、 max(…)、min(…)、avg(…)等</li>
<li>Sort Functions: 数据排序函数, 比如 ：rank(…)、row_number(…)、dense_rank(…)等</li>
<li>Analytics Functions: 统计和比较函数, 比如：lead(…)、lag(…)、 first_value(…)等</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">Function (arg1,..., argn) OVER ([PARTITION BY &lt;...&gt;] [ORDER BY &lt;....&gt;]</span><br><span class="line">[&lt;window_expression&gt;])</span><br></pre></td></tr></tbody></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul>
<li>计算每个渠道订单正退核减后的订单数</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> channel,<span class="keyword">sum</span>(order_num) <span class="keyword">as</span> order_num</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> channel,memberNO,<span class="keyword">if</span>(<span class="keyword">sum</span>(price) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> memberNO)&gt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">as</span> order_num</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line">) <span class="keyword">ord</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> channel</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>计算每个人多个手机号情况下最早的加入时间</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> channel,memberNO,mobile,<span class="keyword">min</span>(join_date) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> mobile) <span class="keyword">as</span> max_join_date</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">member</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="数据排序函数"><a href="#数据排序函数" class="headerlink" title="数据排序函数"></a>数据排序函数</h3><hr>
<p>窗口排序函数提供了数据的排序信息，比如行号和排名。在一个分组的内部将行号或者排名作为数据的一部分进行返回，最常用的排序函数主要包括：</p>
<ul>
<li><p>row_number：根据具体的分组和排序，为每行数据生成一个起始值等于1的唯一序列数</p>
</li>
<li><p>rank：对组中的数据进行排名，如果名次相同，则排名也相同，但是下一个名次的排名序号会出现不连续。比如查找具体条件的topN行</p>
</li>
<li><p>dense_rank：dense_rank函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。当出现名次相同时，则排名序号也相同。而下一个排名的序号与上一个排名序号是连续的。</p>
</li>
<li><p>percent_rank：排名计算公式为：(current rank - 1)/(total number of rows - 1)</p>
</li>
<li><p>ntile：将一个有序的数据集划分为多个桶(bucket)，并为每行分配一个适当的桶数。它可用于将数据划分为相等的小切片，为每一行分配该小切片的数字序号。</p>
</li>
</ul>
<hr>
<ul>
<li>计算每个会员最早加入的那条记录</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> channel,memberNo,mobile</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> channel,memberNo,mobile,row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> memberNo <span class="keyword">order</span> <span class="keyword">by</span> join_date) <span class="keyword">as</span> rn</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">member</span></span><br><span class="line">)mbr</span><br><span class="line"><span class="keyword">where</span> rn=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>计算每个渠道最早一批数据</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> channel,memberNo,mobile</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> channel,memberNo,mobile,<span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> channel <span class="keyword">order</span> <span class="keyword">by</span> batch_date <span class="keyword">desc</span>) <span class="keyword">as</span> rn</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">member</span></span><br><span class="line">)mbr</span><br><span class="line"><span class="keyword">where</span> rn=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="统计和比较函数"><a href="#统计和比较函数" class="headerlink" title="统计和比较函数"></a>统计和比较函数</h3><hr>
<p>常用的分析函数主要包括：</p>
<ul>
<li><p>cume_dist：如果按升序排列，则统计：小于等于当前值的行数/总行数(number of rows ≤ current row)/(total number of rows）。如果是降序排列，则统计：大于等于当前值的行数/总行数。比如，统计小于等于当前工资的人数占总人数的比例 ，用于累计统计。</p>
</li>
<li><p>lead(value_expr[,offset[,default]])：用于统计窗口内往下第n行值。第一个参数为列名，第二个参数为往下第n行（可选，默认为1），第三个参数为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL</p>
</li>
<li><p>lag(value_expr[,offset[,default]])：与lead相反，用于统计窗口内往上第n行值。第一个参数为列名，第二个参数为往上第n行（可选，默认为1），第三个参数为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）</p>
</li>
<li><p>first_value：取分组内排序后，截止到当前行，第一个值</p>
</li>
<li><p>last_value：取分组内排序后，截止到当前行，最后一个值</p>
</li>
</ul>
<hr>
<ul>
<li>统计小于等于当前工资的人数占总人数的比例</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> <span class="keyword">name</span>,</span><br><span class="line"> dept_num <span class="keyword">as</span> deptno,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="keyword">cume_dist</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> cume</span><br><span class="line"><span class="keyword">FROM</span> employee;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>统计按照部门小于等于当前工资的人数占部门总人数的比例</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> <span class="keyword">name</span>,</span><br><span class="line"> dept_num <span class="keyword">as</span> deptno,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="keyword">cume_dist</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> dept_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) <span class="keyword">as</span> cume</span><br><span class="line"><span class="keyword">FROM</span> employee;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>统计每个部门员工工资以及该部门最高的员工工资</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> <span class="keyword">name</span>,</span><br><span class="line"> dept_num <span class="keyword">as</span> deptno,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="keyword">last_value</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> dept_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">RANGE</span></span><br><span class="line"><span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span>) <span class="keyword">as</span> lval</span><br><span class="line"><span class="keyword">FROM</span> employee;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong>：last_value默认的窗口是RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW，表示当前行永远是最后一个值，需改成RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING。</p>
<p><img src="/uploads/Hive/hive_functions_window_expression_compress.png" alt="window_expression" title="window_expression"></p>
<ul>
<li><p>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW<br>为默认值，即当指定了ORDER BY从句，而省略了window从句 ，表示从开始到当前行。</p>
</li>
<li><p>RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING<br>表示从当前行到最后一行</p>
</li>
<li><p>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING<br>表示所有行</p>
</li>
<li><p>n PRECEDING  m FOLLOWING<br>表示窗口的范围是：[（当前行的行数）- n, （当前行的行数）+m]</p>
</li>
</ul>
<h3 id="增强聚合函数"><a href="#增强聚合函数" class="headerlink" title="增强聚合函数"></a>增强聚合函数</h3><p><a href="https://cwiki.apache.org/confluence/display/Hive/Enhanced+Aggregation%2C+Cube%2C+Grouping+and+Rollup" target="_blank" rel="noopener">官网地址</a></p>
<h4 id="GROUPING-SETS"><a href="#GROUPING-SETS" class="headerlink" title="GROUPING SETS"></a>GROUPING SETS</h4><p>实现同一数据集的多重group by操作。事实上GROUPING SETS是多个GROUP BY进行UNION ALL操作的简单表达。</p>
<ul>
<li>统计总的销售记录和每天每个渠道每个区域的销售记录</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(join_date,<span class="string">'1999-01-01'</span>) <span class="keyword">as</span> join_date,<span class="keyword">coalesce</span>(channel,<span class="string">'总计'</span>) <span class="keyword">as</span> channel,<span class="keyword">coalesce</span>(area,<span class="string">'其他'</span>) <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> join_date,channel,area</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span>((),(join_date,channel,area))</span><br></pre></td></tr></tbody></table></figure>
<p>上面sql语句等同于</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'1999-01-01'</span> <span class="keyword">as</span> join_date,<span class="string">'总计'</span> <span class="keyword">as</span> channel,<span class="string">'其他'</span> <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(join_date,<span class="string">'1999-01-01'</span>) <span class="keyword">as</span> join_date,<span class="keyword">coalesce</span>(channel,<span class="string">'总计'</span>) <span class="keyword">as</span> channel,<span class="keyword">coalesce</span>(area,<span class="string">'其他'</span>) <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> join_date,channel,area</span><br></pre></td></tr></tbody></table></figure>
<h4 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h4><p>根据GROUP BY的维度的所有组合进行聚合。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(join_date,<span class="string">'1999-01-01'</span>) <span class="keyword">as</span> join_date,<span class="keyword">coalesce</span>(channel,<span class="string">'总计'</span>) <span class="keyword">as</span> channel,<span class="keyword">coalesce</span>(area,<span class="string">'其他'</span>) <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> join_date,channel,area </span><br><span class="line"><span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上sql语句等同于</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(join_date,<span class="string">'1999-01-01'</span>) <span class="keyword">as</span> join_date,<span class="keyword">coalesce</span>(channel,<span class="string">'总计'</span>) <span class="keyword">as</span> channel,<span class="keyword">coalesce</span>(area,<span class="string">'其他'</span>) <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> join_date,channel,area</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span>((join_date,channel,area),(join_date,area),(join_date,channel),(channel,area),(channel,join_date),(area,channel),(area,join_date),())</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h4><p>CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(join_date,<span class="string">'1999-01-01'</span>) <span class="keyword">as</span> join_date,<span class="keyword">coalesce</span>(channel,<span class="string">'总计'</span>) <span class="keyword">as</span> channel,<span class="keyword">coalesce</span>(area,<span class="string">'其他'</span>) <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> join_date,channel,area </span><br><span class="line"><span class="keyword">with</span> <span class="keyword">rollup</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上sql语句等同于</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(join_date,<span class="string">'1999-01-01'</span>) <span class="keyword">as</span> join_date,<span class="keyword">coalesce</span>(channel,<span class="string">'总计'</span>) <span class="keyword">as</span> channel,<span class="keyword">coalesce</span>(area,<span class="string">'其他'</span>) <span class="keyword">as</span> area,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> sale_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> join_date,channel,area</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span>((join_date,channel,area),(join_date,channel),(join_date),())</span><br></pre></td></tr></tbody></table></figure>
<h3 id="四种排序方式"><a href="#四种排序方式" class="headerlink" title="四种排序方式"></a>四种排序方式</h3><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+SortBy" target="_blank" rel="noopener">官网地址</a></p>
<hr>
<ol>
<li>order by (全局排序)</li>
<li>sort by (分区内排序)</li>
<li>distribute by (数据分发)</li>
<li>cluster by</li>
</ol>
<hr>
<p>持续更新中。。。。</p>
<h3 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h3><h4 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url"></a>parse_url</h4><p>用于解析url相关的参数。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">http_url,</span><br><span class="line">parse_url(http_url, <span class="string">'HOST'</span>) <span class="keyword">as</span> url_host, <span class="comment">--解析host</span></span><br><span class="line">parse_url(http_url, <span class="string">'PATH'</span>) <span class="keyword">as</span> url_path, <span class="comment">--解析path</span></span><br><span class="line">parse_url(http_url, <span class="string">'QUERY'</span>) <span class="keyword">as</span> url_query<span class="comment">--解析请求参数</span></span><br><span class="line"><span class="keyword">from</span> url_info</span><br></pre></td></tr></tbody></table></figure>
<h4 id="collect-set-collect-list"><a href="#collect-set-collect-list" class="headerlink" title="collect_set/collect_list"></a>collect_set/collect_list</h4><p>将分组内的数据放入到一个集合中，具有去重的功能。</p>
<ul>
<li>统计每个渠道有哪些销售区域</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  channel,</span><br><span class="line">  collect_set(area) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> channel) <span class="keyword">as</span> area_set </span><br><span class="line"><span class="keyword">from</span> sale_info</span><br></pre></td></tr></tbody></table></figure>
<p>collect_list：用法和collect_set一样，但是不会去重。</p>
<h4 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace"></a>regex_replace</h4><p>正则匹配文本内容</p>
<ul>
<li>获取埋点数据中的unionid值<br>样例数据值：[{“k”:”a_channel”,”v”:”1211”,”t”:null},{“k”:”b_channel”,”v”:”2”,”t”:null},,{“k”:”unionId”,”v”:”aada12-ixcnudfrtbal”,”t”:null}]</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> regexp_replace(regexp_extract(regexp_extract(te, <span class="string">'(unionId*.*?[:$]".*?["])'</span>,<span class="number">0</span>),<span class="string">'[^:?="]*.?$'</span>,<span class="number">0</span>),<span class="string">'"'</span>,<span class="string">''</span>) <span class="keyword">as</span> unionid</span><br><span class="line"><span class="keyword">from</span> tracking_info</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC拓展（一）：九大组件</title>
    <url>/SpringMVC%E6%8B%93%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面文章是针对于SpringMVC中的具体组件进行源码分析的；本文主要用于补充记录一下关于SpringMVC中九大组件的学习。<br>在<code>DispatcherServlet</code>类中，其在mvc子容器进行初始化时就会完成对九大组件的初始化工作，具体哪九大组件后面会慢慢说到。先来看下在<code>DispatcherServlet</code>中是通过哪些方法来完成初始化工作的,先贴一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.initStrategies(context);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.initMultipartResolver(context);<span class="comment">//文件上传解析器，只允许一个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initLocaleResolver(context);<span class="comment">//本地化解析器，只允许一个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initThemeResolver(context);<span class="comment">//主题解析器，只允许一个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initHandlerMappings(context);<span class="comment">//处理器映射器，允许多个实例（都写出复数了）</span></span><br><span class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);<span class="comment">//处理器适配器，允许多个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);<span class="comment">//处理器异常解析器，允许多个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);<span class="comment">//视图名称解析器，只允许一个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initViewResolvers(context);<span class="comment">//视图解析器，允许多个实例</span></span><br><span class="line">    <span class="keyword">this</span>.initFlashMapManager(context);<span class="comment">//映射管理器</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中的<code>onRefresh</code>方法就是<code>DispatcherServlet</code>的入口方法。在<code>onRefresh</code>中又通过调用<code>initStrategies</code>方法来将各个组件的初始化逻辑进行整合，个人理解其实就是策略套策略，在一个就是职责也明确。<br>在<code>initStrategies</code>方法中又通过调用组件各自的初始化方法来完成具体的初始化工作。从这个地方其实就可以清楚的看出SpringMVC中的9个组件名称了,初始化的顺序按照代码执行流程也是从上到下依次执行。下面就来捋一捋这九大组件的基本职责。</p>
<h1 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h1><p>这个相应小伙伴们也不陌生，做网站多多少少会涉及到文件上传。MultipartResolver就是用来处理上传请求的。其处理方式就是将request包装成<code>MultipartHttpServletRequest</code>。然后我们就可以用MultipartHttpServletRequest这个直接调用getFile获取的文件了。</p>
<h1 id="LocalResolver"><a href="#LocalResolver" class="headerlink" title="LocalResolver"></a>LocalResolver</h1><p>在上面的<code>ViewResolver</code>中提到，解析视图需要两个参数，一个是String类型的逻辑视图名，另外一个是local。<code>LocalResolver</code>的作用就是从request中解析出local的。<br>初始化LocaleResolver（国际化配置）;</p>
<ol>
<li>第一种配置基于URL参数<br>配置如<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;bean id="XXX" class="org.Springframework.web.servlet.i8ln.AcceptHeaderLocaleResolver"&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>配合<code>&lt;a href="?locale=zh_CN"&gt;</code>控制使用国际化化参数。</p>
<ol start="2">
<li>第二种配置基于session<br>如果会话属性不存在，那么通过accept-language HTTP头部确定默认区域<br>第三种配置基于Cookie，这种策略常用于应用不支持会话或者状态必须保持在客户端的情况。<br>配置如<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"XXX"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.Springframework.web.servlet.i8ln.CookieLocaleResolver"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p><strong>LocaleResolver源码：</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>{</span><br><span class="line">    <span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale local)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>第一个方法是从request中解析出local，第二个方法是将local设置到request中。<br>关于local大多数情况下都是用来做国际化处理的。</p>
<h1 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h1><p>解析主题的。这个我平时除了SpringMVC自己提供的功能外，很少自己去扩展使用，即使是换主题也没有做过。不过既然存在肯定是有存在的原因的。对于我们常见的网页界面活着手机界面来说，一套主题无非就是换一套图片，活着css样式文件等等。我们通过ThemeResolver这个就可以实现这样的功能。具体使用其实也就是配一套properties文件供系统在不同的时候读取切换；当然使用这个也是可以实现国际化的。<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>{</span><br><span class="line">    <span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String themeName)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>ThemeSource配置了主题资源，不同用户的不同资源则由主题解析器定义。<br>由<code>org.Springframework.web.servlet.ThemeResolver</code>作为主题解析器的接口<br>该接口有三个实现类：</p>
<ol>
<li>第一个是<code>FixedThemeResolver</code>用于设置固定主题</li>
<li>第二个是<code>CookieThemeResolver</code>效果是将主题以cookie的形式放在客户端的机器上</li>
<li>第三个是<code>SessionThemeResolver</code>效果是将主题保存在HTTP Session中</li>
<li>第四个是<code>AbstractThemeResolver</code>（是CookieThemeResolver和SessionThemeResolver的父类），用户可以继承它来实现自己的主题解析器<br>如果需要根据用户请求改变主题，那么Spring提供了一个已经实现的拦截器ThemeChangeInterceptor<br>主题拦截器的配置如下：<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"XXX"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.Springframework.web.servlet.theme.ThemeChangeInterceptor"</span>&gt;</span><br><span class="line">    &lt;property name="paramName" value="themeName"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>当然还需要在handlerMapping中添加该拦截器:<br></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">"interceptors"</span>&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;ref local=<span class="string">"themeChangeInterceptor"</span>/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><p>对于HandlerMapping来说，其作用就是根据request找到相应的处理器<code>Handler</code>和<code>Intecepter</code>拦截器。具体细节参数上面第一篇文章。<br> 当客户端发出Request时DispatchServlet会将Request提交给HandlerMapping，<br>然后HandlerMapping根据WebApplicationContext的配置回传给DispatcherServlet相应的Controller。<br>（当然调用时会按照优先级进行排序，优先级高的优先调用）<br>默认情况下SpringMVC会加载当前所有实现了HandlerMapping接口的bean，如果只希望加载指定的bean，那么可以如下配置：<br></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;detectAllHandlerMappings&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>之后将按照Dispatcher.properties中所定义的规则来默认加载。</p>
<h1 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h1><p><code>HandlerAdapter</code>就是使用处理器（<code>HandlerMapping</code>）干活的人。为什么呢？来看下代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>是不是一目了然了，在HandlerAdapter接口中提供了<code>handle</code>这样一个方法，参数中Object handler第三个参数其实就是一个处理器，那我们就知道了，handle方法就是使用handler来处理逻辑的。处理之后返回一个<code>ModelAndView</code>。</p>
<h1 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h1><p>这个是SpringMVC中的异常处理组件，HandlerExceptionResolver这个组件的作用就是根据异常设置ModelAndView，然后再将处理结果交给render方法进行渲染。当然render也仅仅只是负责将ModelAndView渲染成页面，ModelAndView的具体来源它不关心。<br>这里需要说明一下，加入在渲染过程中发生异常怎么办？从上面的分析我们可以清楚的知道，<code>HandlerExceptionResolver</code>这个组件对异常的处理结果是<code>ModelAndView</code>，然后再由render方法进行渲染，也就是说<code>HandlerExceptionResolver</code>是在渲染之前工作的，因此渲染过程中发生异常，HandlerExceptionResolver是不会处理的。<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>{</span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>HandlerExceptionResolver中也只有一个方法，这个方法就是从异常中解析出ModelAndView。</p>
<h1 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h1><p>这个其实还是挺有意思的，就是将request请求转换为视图名称。<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestToViewNameTranslator</span> </span>{</span><br><span class="line">    <span class="function">String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>RequestToViewNameTranslator</code>只有一个默认的实现类<code>DefaultRequestToViewNameTranslator</code>。<br>在DefaultRequestToViewNameTranslator具体实现了getViewName(HttpServletRequest request)方法：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> </span>{</span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prefix + <span class="keyword">this</span>.transformPath(lookupPath) + <span class="keyword">this</span>.suffix;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>主要是委派给urlPathHelper帮助类得到请求的后缀名称，比如通过 请求路径比如/glmapper/login.do转换得到/login.do  ；具体怎么转换成视图也会在后面的组件介绍中给出具体的例子。</p>
<h1 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h1><p>ViewResolver的作用是将String类型的逻辑视图根据<code>local</code>解析为<code>View</code>视图的。<br>下面是ViewResolver的源码接口定义：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>{</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale local)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>从代码中可以看到，在ViewResolver中也是只有一个方法，从resolveViewName方法的参数和返回结果就很好的解释了其作用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">形参</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String viewName</td>
<td style="text-align:center">类型的视图名</td>
</tr>
<tr>
<td style="text-align:center">Locale local</td>
<td style="text-align:center">区域，可以用来做国际化</td>
</tr>
</tbody>
</table>
<p><code>View</code>实际上是用来渲染页面的，也就是说将程序返回的结果填入到具体的模板里面，生成具体的视图文件，比如：jsp，ftl，html等。<br>但是这里又会牵扯出两个问题：</p>
<p><strong>用什么模板？</strong><br><strong>参数怎么填入？</strong></p>
<p>当然，这两个问题也就是本小节说的ViewResolver需要解决的问题。大体分为两种：<br>针对单一视图类型的解析器</p>
<p><code>InternalResourceViewResolver</code><br><code>FreeMarkerViewResolver</code></p>
<p>上面两种是用的最多的两种，<code>InternalResourceViewResolver</code>用来解析jsp，而<code>FreeMarkerViewResolver</code>则是针对FreeMarker。</p>
<h2 id="针对同时解析多种类型视图的解析器"><a href="#针对同时解析多种类型视图的解析器" class="headerlink" title="针对同时解析多种类型视图的解析器"></a>针对同时解析多种类型视图的解析器</h2><ul>
<li>BeanNameViewResolver<br>需要同时使用视图名和对应的local来解析视图。它需要将每一个视图名和对应的视图类型配置到相应的properties文件中。（后面讲组件实现细节时给出列子）</li>
</ul>
<ul>
<li>XmlViewResolver<br>XmlViewResolver和BeanNameViewResolver有点差不多，BeanNameViewResolver使用的是xml格式的配置文件。</li>
</ul>
<ul>
<li>ResourceBundleViewResolver<br>这个其实就是根据viewName从Spring容器中查找bean，再根据这个bean来找到对应的视图。</li>
</ul>
<h1 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h1><p>这个在redirect是进行参数传递需要用到。<br>Flashattributes提供了一个请求存储属性，在重定向时非常有用（在重定向之前暂存，以便继续使用）。<br>FlashMap用于保持flashattributes；<br>FlashMapManager用于存储，检索，管理FlashMap实例。<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlashMapManager</span> </span>{</span><br><span class="line">    <span class="function">FlashMap <span class="title">retrieveAndUpdate</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveOutputFlashMap</span><span class="params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>retrieveAndUpdate</code>这个方法是用来恢复参数的，对于恢复过的和超时的参数将都会被删除掉。<br><code>saveOutputFlashMap</code>这个方法是用来保存参数的。<br>FlashMapManager的默认实现机制中参数的存储是放在<code>session</code>中的。我之前在一个项目中就有遇到过这种情况，对于一些我们不想暴露在url中的参数，在进行请求转发时，可以使用<code>@RedirectAttributes</code>将参数保存，然后在下一个处理器中获取到。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇主要是来对九大组件做一个笼统的介绍，细节实现及案例均不涉及；在后续的SpringMVC源码系列中对各个组件的实现细节分析时再一探究竟吧。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC核心（二）：根据启动日志学原理</title>
    <url>/SpringMVC%E6%A0%B8%E5%BF%83%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A0%B9%E6%8D%AE%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>前面一篇文章中讲到，在Spring框架中，我们SpringMVC的加载是通过Servlet容器解析Web.xml来加载初始化SpringIOC容器与SpringMVC的基础环境参数的。 </p>
<p>以下文章中用到的web.xml与日志信息都保存在我的<a href="https://blog.csdn.net/hu_belif/article/details/88625867" target="_blank" rel="noopener">CSDN（点击跳转）</a>上面。</p>
<h1 id="关于Web-xml-中的配置加载顺序"><a href="#关于Web-xml-中的配置加载顺序" class="headerlink" title="关于Web.xml 中的配置加载顺序"></a>关于Web.xml 中的配置加载顺序</h1><p>在我们的Servlet/WEB容器加载后，紧接着就是找到我们项目War包中WEB-INF下的<code>Web.xml</code>文件，加载解析该来启动并初始化我们的Spring容器(IOC容器)。</p>
<p>在web.xml文件中元素的加载顺序与它们在 web.xml 文件中的先后顺序<code>无关</code>。<br>加载的顺序是：<strong>context-param-&gt;listener -&gt; filter -&gt; servletContext-param-&gt;其他web配置</strong>，它用于向 ServletContext 提供键值对，即应用程序上下文信息(是整个容器的根，后面会讲到)。</p>
<p>我们的 listener, filter 等在初始化时会用到这些上下文中的信息；然而对于某些配置节点而言，它们出现的顺序是有先后关联的；以 filter 为例，web.xml 中可以定义多个 filter，与 filter 相关的一个配置节是 filter-mapping，这里一定要注意：对于拥有相同 filter-name 的 filter 和 filter-mapping 配置节点而言，filter-mapping 必须出现在 filter 之后，<em>否则当解析到 filter-mapping 时，它所对应的 filter-name 还未定义</em>。</p>
<p>web 容器启动时初始化每个 filter 时，是按照 filter 配置节点出现的顺序来初始化的，当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 <code>doFilter()</code> 方法的。</p>
<p>servlet 同 filter 类似 ，此处不再赘述(文章最后再啰嗦)。而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的（mapping的等于上面初始化的顺序）。</p>
<hr>
<p><strong>web.xml常见配置详解:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">display-name</td>
<td style="text-align:left">定义当前WEB应用的名字</td>
</tr>
<tr>
<td style="text-align:center">description</td>
<td style="text-align:left">声明WEB应用的描述信息</td>
</tr>
<tr>
<td style="text-align:center">context-param</td>
<td style="text-align:left">元素声明整个应用范围内的初始化参数环境</td>
</tr>
<tr>
<td style="text-align:center">filter</td>
<td style="text-align:left">过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联</td>
</tr>
<tr>
<td style="text-align:center">filter-mapping</td>
<td style="text-align:left">一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联</td>
</tr>
<tr>
<td style="text-align:center">listener</td>
<td style="text-align:left">捕捉服务器的启动和停止，触发相应的方法（servlet的初始化/处理业务/销毁）</td>
</tr>
<tr>
<td style="text-align:center">servlet</td>
<td style="text-align:left">在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的</td>
</tr>
<tr>
<td style="text-align:center">servlet-mapping</td>
<td style="text-align:left">服务器一般为servlet提供一个缺省的URL：<code>http://host/webAppPrefix/servlet/ServletName</code>。但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素。</td>
</tr>
<tr>
<td style="text-align:center">session-config</td>
<td style="text-align:left">如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值（未超时情况下可以存储在本地）。</td>
</tr>
<tr>
<td style="text-align:center">welcome-file-list</td>
<td style="text-align:left">设置欢迎页</td>
</tr>
<tr>
<td style="text-align:center">error-page</td>
<td style="text-align:left">返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。</td>
</tr>
<tr>
<td style="text-align:center">resource-ref</td>
<td style="text-align:left">声明一个资源工厂使用的外部资源</td>
</tr>
</tbody>
</table>
<h1 id="初始化流程分析"><a href="#初始化流程分析" class="headerlink" title="初始化流程分析"></a>初始化流程分析</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[INFO] create webapp with contextPath: </span><br><span class="line">三月 org.apache.coyote.AbstractProtocol init</span><br><span class="line">信息: Initializing ProtocolHandler ["http-bio-8082"]</span><br><span class="line">三月 org.apache.catalina.core.StandardService startInternal</span><br><span class="line">信息: Starting service Tomcat</span><br><span class="line">三月 org.apache.catalina.core.StandardEngine startInternal</span><br><span class="line">信息: Starting Servlet Engine: Apache Tomcat/7.0.47</span><br><span class="line">三月 org.apache.catalina.core.ApplicationContext log</span><br><span class="line">信息: No Spring WebApplicationInitializer types detected on classpath</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>上面这段是tomcat启动创建Servlet容器并根据Web.xml加载Spring容器的日志。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [servletConfigInitParams] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [servletContextInitParams] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [jndiProperties] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [systemProperties] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [systemEnvironment] PropertySource with lowest search precedenceInitialized StandardServletEnvironment with PropertySources [servletConfigInitParams,servletContextInitParams,jndiProperties,systemProperties,systemEnvironment]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这里是tomcat根据web.xml解析加载spring后，springWeb模块中的初始化的日志。<br>这个时候WebApplicationContext已经算是加载好了，相当于加载了标准的ServletContext的参数环境在SpringIOC（等于说是全局的一个参数环境）环境中。</li>
</ul>
<p>下面我们简单来说一下这个WebApplicationContext容器的创建与加载。</p>
<ul>
<li>首先看一下源码<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) {</span><br><span class="line">                   <span class="keyword">this</span>.context = <span class="keyword">this</span>.createWebApplicationContext(servletContext);</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) {</span><br><span class="line">                   ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext)<span class="keyword">this</span>.context;</span><br><span class="line">                   <span class="keyword">if</span> (!cwac.isActive()) {</span><br><span class="line">                       <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) {</span><br><span class="line">                           ApplicationContext parent = <span class="keyword">this</span>.loadParentContext(servletContext);</span><br><span class="line">                           cwac.setParent(parent);</span><br><span class="line">                       }</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">this</span>.configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line">               ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>上面的部分代码可以看出，初始化时候通过createWebApplicationContext(servletContext);声明一个WebApplicationContext<br>并赋值给ServletContext的org.springframework.web.context.WebApplicationContext.ROOT属性，作为WebApplicationContext的根上下文（root WebapplicationContext）,并放入ServletContext。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">DEBUG (org.springframework.web.filter.CharacterEncodingFilter:<span class="number">177</span>) - Initializing filter <span class="string">'CharacterEncodingFilter'</span></span><br><span class="line">DEBUG (org.springframework.web.filter.CharacterEncodingFilter:<span class="number">202</span>) - Filter <span class="string">'CharacterEncodingFilter'</span> configured successfully</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这里加载了web.xml中的CharacterEncodingFilter乱码过滤器。</li>
</ul>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><p>接下来是根据Web.xml来初始化DispatcherServlet。<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">DEBUG (org.springframework.web.servlet.DispatcherServlet:<span class="number">118</span>) - Initializing servlet <span class="string">'DispatcherServlet'</span></span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [servletConfigInitParams] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [servletContextInitParams] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [jndiProperties] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [systemProperties] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">109</span>) - Adding [systemEnvironment] PropertySource with lowest search precedence</span><br><span class="line">DEBUG (org.springframework.web.context.support.StandardServletEnvironment:<span class="number">124</span>) - Initialized StandardServletEnvironment with PropertySources [servletConfigInitParams,servletContextInitParams,jndiProperties,systemProperties,systemEnvironment]</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>首先从Spring父容器中拿到spring已经初始化好的环境配置及参数。<br>DispatcherServlet作为SpringMVC的核心，其中很多的东西需要我们来慢慢推敲。<br>在这里我们先来看一下<a href="http://www.hushaohui.site/SpringMVC拓展（一）：九大组件/">DispatcherServlet的九个组件（也是它基础设施的初始化）</a>，这里提一下Spring的基础设施—&gt;<code>BeanFactory</code>。<br>剩下关于日志跟踪的流程已经在本人的<a href="https://blog.csdn.net/hu_belif/article/details/88625867" target="_blank" rel="noopener">CSDN</a>中加上注解，大家感兴趣的自己可以看看。</p>
<hr>
<p><img src="/uploads/SpringMVC核心/DispatcherServlet_ExtendsRelationship.png" alt="SpringMVC-Dispatcherservlet继承关系图" title="Dispatcherservlet继承关系图"></p>
<p>我们根据启动日志和Dispatcherservlet继承关系图继续来研究SpringMVC的原理。（后面会继续更新Dispacherservlet）</p>
<h2 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h2><p>首先需要引入一个servlet的基本知识。<br>Servlet接口是基于<code>HTTP</code>协议的，servlet框架主要由两个java包组成:<br><code>javax.servlet</code>（提供所有必须实现或扩展的通用接口和类）和<code>javax.servlet.http</code>（定义了采用HTTP通信协议的HttpServlet类,是DispatcherServlet间接父类，同继承一个Servlet接口）</p>
<p><strong>Servlet的生命周期是由servlet容器来控制的，它的生命周期分为三个阶段:</strong></p>
<ol>
<li>初始化阶段 –init()</li>
</ol>
<ul>
<li>servlet容器加载servlet类，将.class文件读入内存(JVM的知识点)； </li>
<li>创建ServletConfig对象，包含了servlet的初始化配置信息； </li>
<li>创建servlet对象，调用servlet对象的<code>init()</code>方法进行初始化； </li>
<li>初始化的过程通过将当前的servlet类型转化为BeanWrapper类型实例（其目的是方便对应属性注入，属性可以在web.xml中通过<context-param>进行注入（<code>Context-param创建的bean是全局共享的</code>），其对应的属性位于其父类FrameworkServlet中）；</context-param></li>
<li>属性注入的步骤：封装及验证初始化参数–&gt;将当前servlet实例转化为BeanWrapper实例–&gt;注册相对于Resource（Resource类型的属性将会使用ResourceEditor进行解析）的属性编辑器–&gt;属性注入–&gt;servletBean的初始化（主要是对webApplicationContext实例进行填充） 。</li>
</ul>
<ol start="2">
<li>运行阶段 –service()<br>DispatcherServlet接受请求时，针对请求创建servletRequest，servletResponse，调用<code>service()</code>方法（通过servletRequest获得请求信息，根据servletResponse生成相应结果），最后销毁servletRequest，servletResponse两个对象。<br>servlet被设计为请求驱动，请求会被封装为HttpServletRequest对象，然后传给对应服务方法。<br>请求的类型一共有八种：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">GET</td>
<td style="text-align:left">请求指定的页面信息，并返回实体主体。（read）</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">POST</td>
<td style="text-align:left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。(create)</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">PUT</td>
<td style="text-align:left">从客户端向服务器传送的数据取代指定的文档的内容。（update）</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">DELETE</td>
<td style="text-align:left">请求服务器删除指定的页面。（delete）</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">HEAD</td>
<td style="text-align:left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">CONNECT</td>
<td style="text-align:left">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">TRACE</td>
<td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody>
</table>
<p>关于RESTful Api的推荐文章:(<a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a>)</p>
<ol start="3">
<li>销毁阶段 –destory()<br>调用servlet容器的<code>destory()</code>方法之后再销毁servlet对象，我们可以将一些servlet占用的资源的释放 放在destroy()方法中实现以优化我们的代码，减少内存泄漏。</li>
</ol>
<p>下一篇：<a href="http://www.hushaohui.site/SpringMVC%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ADispatcherServlet/">DispatcherServlet</a><br><code>本文若有任何错误言论，请大神不吝赐教给予纠正，避免误导他人</code></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop数据传输工具</title>
    <url>/Sqoop%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Sqoop 是一种开源的数据传输工具，用于在 Hadoop 和关系数据库（RDBMS）或其他数据主机之间传输数据的工具。 （<strong>该技术已于2021年下半年加入Apache Attic，但仍会发布新版本和修复bug</strong>）<br>Sqoop 可以将数据从 MySQL 或 Oracle 或大型机等关系数据库管理系统 (RDBMS) 导入 Hadoop 分布式文件系统 (HDFS)，在 Hadoop MapReduce 中转换数据，然后将数据导出回 RDBMS 。<br>Sqoop 使用 MapReduce 导入和导出数据，提供并行操作和容错。</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ol>
<li><p>Sqoop1</p>
<ul>
<li>sqoop版本号为1.4.x为sqoop1</li>
<li>sqoop1在该版本是通过cli控制台中输入链接及密码后直接提交的方式访问目标库或存储地址</li>
<li>sqoop1链接信息必须符合jdbc模型</li>
</ul>
</li>
<li><p>Sqoop2</p>
<ul>
<li>sqoop2版本号为1.99.x为sqoop2</li>
<li>sqoop2加入了server服务端的概念，以此可以所有的连接器集中管理</li>
<li>交互/操作方式更多花样（API/WEB UI/CLI）<br>Sqoop两个版本的交互方式感觉大相径庭，实际操作上对于开发者更加友好了，不同数据库不同数据模型间可灵活配置的解决方案也更多了（对于运维同学而言配置起来相对可能会繁琐一些）</li>
</ul>
</li>
</ol>
<h3 id="支持的版本"><a href="#支持的版本" class="headerlink" title="支持的版本"></a>支持的版本</h3><p>本文按照Sqoop1版本 <code>v1.4.6</code> 编写。实际使用也建议选择该版本及以上版本。</p>
<h3 id="兼容数据库"><a href="#兼容数据库" class="headerlink" title="兼容数据库"></a>兼容数据库</h3><p>MySQL，PostgreSQL，Oracle，HSQLDB，CUBRID等其他jdbc兼容的数据库。</p>
<h4 id="兼容性说明"><a href="#兼容性说明" class="headerlink" title="兼容性说明"></a>兼容性说明</h4><p><a href="https://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html#_compatibility_notes" target="_blank" rel="noopener">官网兼容性说明</a></p>
<h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><ul>
<li><p>时间字段值为<code>0000-00-00\</code>默认情况下会转换为null值；也可以配置四舍五入取值</p>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="regexp">//db</span>.example.com/someDb?zeroDateTimeBehavior=round</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>Sqoop 目前无法导入大于 <strong>2147483647</strong> 的 UNSIGNED 值。</p>
</li>
<li>Sqoop 的直接模式不支持导入 <code>BLOB</code>/<code>CLOB</code> 或 <code>LONGVARBINARY</code> 列；对这些列使用基于 JDBC 的导入建议加上<code>--inline-lob-limit</code>限制下；并且不要在导入工具添加 <code>--direct</code> 参数。</li>
<li>Sqoop 目前不支持直接模式下从视图导入；不要在导入工具添加 <code>--direct</code> 参数。</li>
</ul>
<h5 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><p>PostgreSQL只有8.3+版本以上支持<code>import</code>命令直连模式，其他暂不支持直连模式；除<code>import</code>命令外不要在导入工具添加 <code>--direct</code> 参数。</p>
<h5 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h5><ul>
<li>DATE, TIME, TIMESTAMP 类型转换到Hive里会被处理为 String</li>
<li>NUMERIC, DECIMAL 类型转换到Hive里会被处理为 DOUBLE</li>
<li><p>tinyInt默认转换boolean后为空，需要配置在连接信息后配置tinyInt1isBit=false</p>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="regexp">//db</span>.example.com/someDb?tinyInt1isBit=false</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><h4 id="基本语法结构"><a href="#基本语法结构" class="headerlink" title="基本语法结构"></a>基本语法结构</h4><figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">$ sqoop help</span><br><span class="line">用法: sqoop COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line">可用命令参数（基本命令）:</span><br><span class="line">  codegen            生成代码以与数据库记录交互</span><br><span class="line">  create-hive-table  将表定义导入 Hive</span><br><span class="line">  <span class="keyword">eval</span>               评估 SQL 语句并显示结果 [常用]</span><br><span class="line">  export             将 HDFS 目录导出到数据库表 [常用]</span><br><span class="line">  help               列出可用命令</span><br><span class="line">  import             将表从数据库导入 HDFS [常用]</span><br><span class="line">  import-all-tables  将多张表从数据库导入 HDFS,可以整库的import</span><br><span class="line">  import-mainframe   将某个节点主机数据集导入 HDFS</span><br><span class="line">  list-databases     列出服务器上的可用数据库 [常用]</span><br><span class="line">  list-tables        列出数据库中的可用表 [常用]</span><br><span class="line">  version            显示版本信息</span><br><span class="line"></span><br><span class="line">有关特定命令的信息，请参见“sqoop help COMMAND”。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>eval</code> 常用来做连接测试或简单的远程数据库查询</li>
<li><code>export</code> Sqoop主要功能之一，从hadoop导出数据</li>
<li><code>import</code> Sqoop主要功能之一，从hadoop导入数据</li>
<li><code>list-databases</code> 内置了<code>show databases</code>语句</li>
<li><code>list-tables</code> 内置了<code>show tables</code>语句</li>
</ul>
<h4 id="导入语法结构"><a href="#导入语法结构" class="headerlink" title="导入语法结构"></a>导入语法结构</h4><figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">$ sqoop import</span><br><span class="line">$ sqoop-import</span><br><span class="line"></span><br><span class="line">用法: sqoop import [GENERIC-ARGS] [TOOL-ARGS] 或者sqoop-import [GENERIC-ARGS] [TOOL-ARGS]</span><br><span class="line"></span><br><span class="line">常见基本命令参数（工具命令）:</span><br><span class="line">   --<span class="keyword">connect</span> &lt;jdbc-uri&gt;               指定 JDBC 连接字符串</span><br><span class="line">   --<span class="keyword">connect</span>-manager &lt;class-name&gt;     指定要使用的连接管理器类</span><br><span class="line">   --driver &lt;class-name&gt;              手动指定要使用的 JDBC 驱动程序类</span><br><span class="line">   --hadoop-mapred-home &lt;dir&gt;         覆盖 $HADOOP_MAPRED_HOME</span><br><span class="line">   --help                             打印使用说明</span><br><span class="line">   --password-file                    设置包含身份验证密码的文件的路径</span><br><span class="line">   -P                                 从控制台读取密码</span><br><span class="line">   --password &lt;password&gt;              设置认证密码</span><br><span class="line">   --username &lt;username&gt;              设置认证用户名</span><br><span class="line">   --verbose                          工作时打印更多信息</span><br><span class="line">   --hadoop-home &lt;dir&gt;                已弃用。覆盖 $HADOOP_HOME</span><br><span class="line"></span><br><span class="line">常见导入控制命令参数（工具命令）:</span><br><span class="line">   --append                           将数据追加到 HDFS 中的现有数据集</span><br><span class="line">   --as-sequencefile                  import序列化的文件</span><br><span class="line">   --as-textfile                      import plain文件，默认textfile</span><br><span class="line">   --columns &lt;col,col,col…&gt;           指定需要导入的列名，逗号分隔；比如：--columns <span class="string">"id,name"</span></span><br><span class="line">   --<span class="keyword">delete</span>-target-dir                删除存在的import目标目录</span><br><span class="line">   --direct                           直连模式，速度更快（HBase不支持）</span><br><span class="line">   --fetch-size &lt;n&gt;                   一次从数据库读取 n 个实例，即n条数据；默认是<span class="number">5000</span></span><br><span class="line">   -<span class="keyword">m</span>,--num-mappers &lt;n&gt;               建立 n 个并发执行task import；默认是<span class="number">4</span>个</span><br><span class="line">   -e,--query &lt;statement&gt;             构建表达式&lt;statement&gt;执行；查询结果导入</span><br><span class="line">   --<span class="keyword">split</span>-by &lt;column-name&gt;           根据column分隔实例</span><br><span class="line">   --autoreset-to-one-mappe           如果没有主键和<span class="keyword">split</span>-by 用one mapper import （<span class="keyword">split</span>-by 和此选项不共存）</span><br><span class="line">   --table &lt;table-name&gt;               指定表名import</span><br><span class="line">   --target-dir &lt;d&gt;                   HDFS 目标目录</span><br><span class="line">   --warehouse-dir &lt;d&gt;                HDFS 表目标的父级</span><br><span class="line">   --where &lt;where clause&gt;             指定where从句，如果有双引号，注意转义；不能用<span class="keyword">or</span>，子查询，<span class="keyword">join</span></span><br><span class="line">   -z,--compress                      开启压缩</span><br><span class="line">   --null-string &lt;null-string&gt;        string列为空指定为此值；如果不设置，会指定为<span class="string">"null"</span></span><br><span class="line">   --null-non-string &lt;null-string&gt;    非string列为空指定为此值； 如果不设置，会指定为<span class="string">"null"</span></span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></tbody></table></figure>
<p>导入参数常用的就是以上这部分，<a href="#导入样例">导入样例</a></p>
<p>&nbsp;</p>
<h4 id="导出语法结构"><a href="#导出语法结构" class="headerlink" title="导出语法结构"></a>导出语法结构</h4><p><a href="#导入语法结构">常见基本命令参数同导入语法结构</a></p>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">$ sqoop export (generic-args) (export-args)</span><br><span class="line">$ sqoop-export (generic-args) (export-args)</span><br><span class="line"></span><br><span class="line">用法: sqoop export [GENERIC-ARGS] [TOOL-ARGS] 或者sqoop-export [GENERIC-ARGS] [TOOL-ARGS]</span><br><span class="line"></span><br><span class="line">常见导入控制命令参数（工具命令）:</span><br><span class="line">--columns &lt;col,col,col…&gt;               要导出到表的列名，逗号分隔</span><br><span class="line">--direct                               直连模式</span><br><span class="line">--export-dir &lt;dir&gt;                     导出的 HDFS 源路径</span><br><span class="line">-<span class="keyword">m</span>,--num-mappers &lt;n&gt;                   使用n个<span class="keyword">map</span>任务并行导出</span><br><span class="line">--table &lt;table-name&gt;                   要填充的表</span><br><span class="line">--call &lt;stored-proc-name&gt;              要调用的存储过程</span><br><span class="line">--update-key &lt;col-name&gt;                用于更新的锚列;如果有多个列，请使用逗号分隔的列列表。</span><br><span class="line">--update-mode &lt;mode&gt;                   指定当在数据库中找到具有不匹配键的新行时如何执行更新。模式的合法值包括 updateonly（默认）和 allowinsert。</span><br><span class="line">--input-null-string &lt;null-string&gt;      字符串列被解释为 null 的字符串</span><br><span class="line">--input-null-non-string &lt;null-string&gt;  对于非字符串列，要解释为 null 的字符串</span><br><span class="line">--staging-table &lt;staging-table-name&gt;   在将数据插入目标表之前将在其中暂存数据的表。</span><br><span class="line">--clear-staging-table                  表示可以删除临时表中存在的任何数据。</span><br><span class="line">--batch                                使用批处理模式执行基础语句。</span><br></pre></td></tr></tbody></table></figure>
<p>导出参数常用的就是以上这部分，<a href="#导出样例">导出样例</a></p>
<p>&nbsp;</p>
<h3 id="常用数据模型转换"><a href="#常用数据模型转换" class="headerlink" title="常用数据模型转换"></a>常用数据模型转换</h3><figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">--<span class="keyword">map</span>-column-hive col2=String,col3=String <span class="comment"># 导入列类型映射hive类型，通用转换，数组或者json转string后导入hive</span></span><br><span class="line">--<span class="keyword">map</span>-column-java col2=String,col3=String <span class="comment"># 导入列类型映射java类型，通用转换，数组或者json转string后导入hive</span></span><br><span class="line">--<span class="keyword">map</span>-column-hive col1=<span class="string">'DECIMAL(10%2C2)'</span> <span class="comment"># Decimal精度丢失问题配置hive精度转换（hive是double）</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="常用样例"><a href="#常用样例" class="headerlink" title="常用样例"></a>常用样例</h3><h4 id="导入样例"><a href="#导入样例" class="headerlink" title="导入样例"></a>导入样例</h4><figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">-D mapred.job.queue.name=hap.testqueue \</span><br><span class="line">--<span class="keyword">connect</span> <span class="string">"jdbc:postgresql://10.101.66.10:3601/testdb?currentSchema=public"</span> \</span><br><span class="line">--username admin \</span><br><span class="line">--password admin@1 \</span><br><span class="line">--table test_tab \</span><br><span class="line">--columns <span class="string">"col1,col2,col3"</span> \</span><br><span class="line">--where <span class="string">"increment_date='<span class="subst">${increment_date}</span>'"</span> \</span><br><span class="line">-<span class="keyword">m</span> <span class="number">3</span> \</span><br><span class="line">--fields-terminated-by <span class="string">"\001"</span> \</span><br><span class="line">--lines-terminated-by <span class="string">"\n"</span> \</span><br><span class="line">--<span class="keyword">delete</span>-target-dir \</span><br><span class="line">--null-string <span class="string">'\\N'</span>  \ <span class="comment"># NULL字符转空字符串</span></span><br><span class="line">--null-non-string <span class="string">'\\N'</span> \ <span class="comment"># 非String类型空值转空字符串</span></span><br><span class="line">--out-dir <span class="string">"<span class="subst">${home}</span>/.sqoop/"</span> \ <span class="comment"># 配置java编译文件输出目录</span></span><br><span class="line">--hive-delims-replacement <span class="string">""</span> \</span><br><span class="line">--<span class="keyword">map</span>-column-java col1=String,col2=String \ <span class="comment"># 数据类型转换</span></span><br><span class="line">--<span class="keyword">map</span>-column-hive col1=String,col2=String \ <span class="comment"># 数据类型转换</span></span><br><span class="line">--target-dir /DATA/TMP/test_tab_hive/date=${increment_date}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="导出样例"><a href="#导出样例" class="headerlink" title="导出样例"></a>导出样例</h4><figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">-D mapred.job.queue.name=hap.testqueue \</span><br><span class="line">--<span class="keyword">connect</span> <span class="string">"jdbc:postgresql://10.101.66.10:3601/testdb?currentSchema=public"</span> \</span><br><span class="line">--username admin \</span><br><span class="line">--password admin@1 \</span><br><span class="line">--table test_tab \</span><br><span class="line">--hcatalog-database tmp \</span><br><span class="line">--hcatalog-table test_tab_hive \</span><br><span class="line">--hcatalog-partition-<span class="keyword">keys</span> date \</span><br><span class="line">--hcatalog-partition-<span class="keyword">values</span> ${date} \</span><br><span class="line">--columns <span class="string">"col1,col2,col3"</span> \</span><br><span class="line">--batch \</span><br><span class="line">--num-mappers <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>数仓</tag>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>Sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC核心（三）:DispatcherServlet</title>
    <url>/SpringMVC%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ADispatcherServlet/</url>
    <content><![CDATA[<p><img src="/uploads/SpringMVC核心/DispatcherServlet_ExtendsRelationship.png" alt="SpringMVC-Dispatcherservlet继承关系图" title="Dispatcherservlet继承关系图"><br>DispatcherServlet是SpringMVC核心类，起到了前端控制器（Front controller）的作用，主要负责请求处理/分发等工作。<br>DispatcherServlet在初始化的过程中，会建立一个自己的IoC容器上下文<code>Servlet WebApplicationContex</code>t，会以ContextLoaderListener建立的根上下文(root WebapplicationContext)作为自己的父级上下文。DispatcherServlet持有的上下文默认的实现类是<code>XmlWebApplicationContext</code>。</p>
<p>根据图中的结构，DispatcherServlet的继承关系大概就是这样。那么它的本质还是一个servlet，Servlet的声明周期在<a href="http://www.hushaohui.site/SpringMVC%E6%A0%B8%E5%BF%83%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A0%B9%E6%8D%AE%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97%E5%AD%A6%E5%8E%9F%E7%90%86/">上一篇文章</a>中已经简单说过了。</p>
<h2 id="这篇文章简要分析一下DispatcherServlet在这三个阶段分别做了什么。"><a href="#这篇文章简要分析一下DispatcherServlet在这三个阶段分别做了什么。" class="headerlink" title="这篇文章简要分析一下DispatcherServlet在这三个阶段分别做了什么。"></a>这篇文章简要分析一下DispatcherServlet在这三个阶段分别做了什么。</h2><h1 id="DispatcherServlet的初始化"><a href="#DispatcherServlet的初始化" class="headerlink" title="DispatcherServlet的初始化"></a>DispatcherServlet的初始化</h1><p>它初始化的方法在它的父类(HttpServletBean)中；看一下HttpServletBean的init()方法：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) {</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Initializing servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            PropertyValues pvs = <span class="keyword">new</span> HttpServletBean.ServletConfigPropertyValues(<span class="keyword">this</span>.getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.getEnvironment()));</span><br><span class="line">            <span class="keyword">this</span>.initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (BeansException var4) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isErrorEnabled()) {</span><br><span class="line">                <span class="keyword">this</span>.logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>, var4);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.initServletBean();<span class="comment">//初始化Servlet WebApplicationContext</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) {</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>通过Web.xml中的<init-param>配置，读取配置文件配置相关的Bean，然后通过调用FrameworkServlet重写后的initServletBean()来初始化一个Servlet-WebApplicationContext（DispatcherServlet的上下文容器）。</init-param></p>
<p><strong>之所以说是调用FrameworkServlet重写后的initServletBean()，因为以下的缘故：</strong><br>看一下重写后的initServletBean()方法：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) {</span><br><span class="line">            <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.webApplicationContext = <span class="keyword">this</span>.initWebApplicationContext();<span class="comment">//后面这个方法是获取一个webApplicationContext的实例</span></span><br><span class="line">            <span class="keyword">this</span>.initFrameworkServlet();<span class="comment">//</span></span><br><span class="line">        } <span class="keyword">catch</span> (ServletException var5) {</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var5);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException var6) {</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var6);</span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) {</span><br><span class="line">            <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">            <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"': initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>之前提到Servlet容器在启动的时候，通过ContextLoaderListener创建一个根上下文（root WebapplicationContext），并配置到ServletContext中。</p>
<p>图解<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet" target="_blank" rel="noopener">引自官网图</a>：<br><img src="/uploads/SpringMVC核心/ServletContext中的容器图解.jpg" alt="ServletContext中的容器图解" title="ServletContext容器图解"></p>
<p><strong>可以看出FrameworkServlet这个类做的作用是用来创建WebApplicationContext上下文的。</strong></p>
<p><strong> 大致过程如下：</strong><br>首先检查webApplicationContext入是否通过构造函数注，如果有的话，直接使用，并将根上下文设置为自己的父上下文。<br>如果webApplicationContext没有注入，则检查是否在ServletContext已经注册过，如果已经注册过，直接返回使用。<br>如果没有注册过，将重新新建一个webApplicationContext。将根上下文设置为父级上下文。<br>不管是何种策略获取的webApplicationContext，都将会调用onRefresh()方法，onRefresh方法会调用initStrategies()方法(DispatcherServlet实现了这两个方法)，通过上下文初始化HandlerMappings、HandlerAdapters、ViewResolvers等等（详细见：<a href="http://www.hushaohui.site/SpringMVC%E6%8B%93%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/">SpringMVC拓展（一）：九大组件</a>）。<br>最后，同样会将所得webApplicationContext注册到ServletContext中，<strong>而initFrameworkServlet()默认的实现是空的。这也可算是SpingMVC留的一个扩展点。</strong><br>具体的业务代码就不贴出来了，感兴趣的可以自行翻阅源码或下方留言。</p>
<h1 id="DispatcherServlet处理请求"><a href="#DispatcherServlet处理请求" class="headerlink" title="DispatcherServlet处理请求"></a>DispatcherServlet处理请求</h1><p>一个请求进来，如果请求的方法是PATCH或者空，直接调用processRequest()方法；否则，将调用父类(FrameworkServlet)的service()的方法，即HttpServlet的service方法, 而这里会根据请求方法，去调用相应的doGet、doPost、doPut……<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">       HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">       <span class="keyword">if</span> (HttpMethod.PATCH != httpMethod &amp;&amp; httpMethod != <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">super</span>.service(request, response);</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>而这里的do xxx系列处理请求的方法的实现并不是在HttpServlet类中的，而是在FrameworkServlet类中。在FrameworkServlet中do xxx系列实现中，都调用了上面提到的processRequest方法。<br><strong>example：</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">       <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">       <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">       <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">       <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>以上的方法全都要先走processRequest(request, response)，我们再来看一下processRequest():</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">  Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 取得当前线程的 LocaleContext 。默认为空</span></span><br><span class="line">  LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">  <span class="comment">// 创建LocaleContext，该接口表示区域内容。主要作用是封装请求的 Locale 信息</span></span><br><span class="line">  LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line">  <span class="comment">// 取得当前线程的 RequestAttributes 。默认为空</span></span><br><span class="line">  RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">  <span class="comment">// 2.创建 RequestAttributes，该接口封装了本次请求的 rqeust，response 信息。通过它可以很方便的操作 rqeust 的属性 </span></span><br><span class="line">  ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">  WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">  asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line">  <span class="comment">// 3.初始化 ContextHolders</span></span><br><span class="line">  initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 服务处理，留给子类实现</span></span><br><span class="line">    doService(request, response);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (ServletException ex) {</span><br><span class="line">    failureCause = ex;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">    failureCause = ex;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    failureCause = ex;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> {</span><br><span class="line">    <span class="comment">// 5. 释放 ContextHolders</span></span><br><span class="line">    resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">    <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) {</span><br><span class="line">      requestAttributes.requestCompleted();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      <span class="keyword">if</span> (failureCause != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Could not complete request"</span>, failureCause);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">          logger.debug(<span class="string">"Leaving response open for concurrent processing"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">this</span>.logger.debug(<span class="string">"Successfully completed request"</span>);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>为什么都走这个方法？</strong></p>
<blockquote>
<p>为了避免子类重写它，该方法用final修饰。</p>
</blockquote>
<blockquote>
<p>首先调用initContextHolders方法,将获取到的localeContext、requestAttributes、request绑定到线程上。</p>
</blockquote>
<blockquote>
<p>然后调用doService()方法，doService()具体是由子类DispatcherServlet做的实现的。</p>
</blockquote>
<blockquote>
<p>当doService()执行完成后，调用resetContextHolders()，解除localeContext(为了让web应用程序支持国际化，必须识别每个用户的首选区域，并根据这个区域显示内容。)等信息与线程的绑定。</p>
</blockquote>
<blockquote>
<p>最终调用publishRequestHandledEvent()发布一个处理完成的事件。</p>
</blockquote>
<blockquote>
<p>知道为什么了吗？所有的操作url请求的前后资源配置及业务处理都在这个方法中的前后做了统一处理，这样子的设计不正是我们常用的代码设计规范嘛。不难看出，FrameworkServlet把GET请求和POST请求都统一用processRequest()来处理，而具体的服务细节交给子类DispatcherServlet去处理。</p>
</blockquote>
<p>这里简单拓展一下resetContextHolders()：<br>在Web开发中，service层或者某个工具类中需要获取到HttpServletRequest对象还是比较常见的。一种方式是将HttpServletRequest作为方法的参数从controller层一直放下传递，不过这种有点费劲，且做起来不是优雅；还有另一种则是RequestContextHolder，直接在需要用的地方使用如下方式取HttpServletRequest即可。原理：利用了ThreadLocal。</p>
<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>DispatcherServlet对于URL的请求做具体的业务逻辑处理，先来看看最核心的doService()(重写父类方法)：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) {</span><br><span class="line">            String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"DispatcherServlet with name '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span> + resumed + <span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//保存请求属性的快照--缓存，以防发生include，以便能够在include之后恢复原始属性。</span></span><br><span class="line">        Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) {<span class="comment">//利用WebUtils工具类做请求属性的快照是否为null的判断，不等于空就保存当前的请求属性快照</span></span><br><span class="line">            attributesSnapshot = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Enumeration attrNames = request.getAttributeNames();</span><br><span class="line"></span><br><span class="line">            label108:<span class="comment">//break的高级用法，常用于多层循环跳出</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">                String attrName;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    <span class="keyword">if</span> (!attrNames.hasMoreElements()) {</span><br><span class="line">                        <span class="keyword">break</span> label108;<span class="comment">//结束循环</span></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    attrName = (String)attrNames.nextElement();</span><br><span class="line">                } <span class="keyword">while</span>(!<span class="keyword">this</span>.cleanupAfterInclude &amp;&amp; !attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>));</span><br><span class="line"></span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.getWebApplicationContext());</span><br><span class="line">        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">        request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="keyword">this</span>.getThemeSource());<span class="comment">//属性注入</span></span><br><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);<span class="comment">//获取可能存在的缓存状态</span></span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) {</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.doDispatch(request, response);<span class="comment">//处理请求的核心BOSS</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);<span class="comment">//把当前请求保存快照或缓存</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>DispatcherServlet类中的doService()方法实现会调用doDispatch()方法，这里请求分发处理的主要执行逻辑。</p>
<p>个人认为这个方法才是真正处理请求的函数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       HttpServletRequest processedRequest = request;</span><br><span class="line">       HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">       WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">           Object dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> {</span><br><span class="line">               <span class="comment">// 1. 判断用户的请求是否为文件上传，通过MultipartResolver解析</span></span><br><span class="line">               processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">               multipartRequestParsed = processedRequest != request;</span><br><span class="line">               <span class="comment">// 2. 获取通过HandlerMapping映射处理器和拦截器包装成一个HandlerExecutionChain(处理执行链)</span></span><br><span class="line">               mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);<span class="comment">//获取映射到的handler</span></span><br><span class="line">               <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) {</span><br><span class="line">                   <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               }</span><br><span class="line">               <span class="comment">// 3. 将处理器包装成相应的适配器</span></span><br><span class="line">               HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">               </span><br><span class="line">               <span class="comment">/*******此处省略若干代码行*****/</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 4. 执行处理器相关的拦截器的预处理</span></span><br><span class="line">               <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               }</span><br><span class="line">                <span class="comment">// 5. 由适配器执行处理器</span></span><br><span class="line">               mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">               <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               }</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">               <span class="comment">// 6. 拦截器后处理</span></span><br><span class="line">               mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">           } <span class="keyword">catch</span> (Exception var20) {</span><br><span class="line">               dispatchException = var20;</span><br><span class="line">           } <span class="keyword">catch</span> (Throwable var21) {</span><br><span class="line">               dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, var21);</span><br><span class="line">           }</span><br><span class="line">            <span class="comment">// 7. 视图渲染</span></span><br><span class="line">           <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">       } <span class="keyword">catch</span> (Exception var22) {</span><br><span class="line">           <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">       } <span class="keyword">catch</span> (Throwable var23) {</span><br><span class="line">           <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, var23));</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">               <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) {</span><br><span class="line">                   mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">               }</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) {</span><br><span class="line">               <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<p><strong>doDispatch主要流程是：</strong></p>
<ol>
<li>先判断是否Multipart类型的请求。如果是则通过multipartResolver解析request。</li>
<li>通过getHandler方法找到从HandlerMapping找到该请求对应的handler,如果没有找到对应的handler则抛出异常。</li>
<li>通过getHandlerAdapter方法找到handler对应的HandlerAdapter。</li>
<li>如果有拦截器，执行拦截器preHandler方法。</li>
<li>HandlerAdapter执行handle方法处理请求，返回ModelAndView。</li>
<li>如果有拦截器，执行拦截器postHandle方法。</li>
<li>然后调用processDispatchResult方法处理请求结果，封装到response中。</li>
</ol>
<p>具体的详细执行流程见：<a href="http://www.hushaohui.site/SpringMVC%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B/">SpringMVC核心（一）：核心业务流程</a></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>SpringMVC框架是围绕DispatcherServlet设计的。DispatcherServlet负责将请求分发给对应的处理程序。<br>那么剩下要分析的的就是三个类,简单看下:</p>
<ol>
<li><p>HttpServletBean 进行初始化工作。</p>
</li>
<li><p>FrameworkServlet 初始化 WebApplicationContext,并提供doService()方法预处理请求。</p>
</li>
<li><p>DispatcherServlet 具体分发请求等处理。</p>
</li>
</ol>
<p><strong>后期持续更新….</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
</search>
